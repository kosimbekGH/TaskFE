(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-videogular', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-videogular'] = {}, global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators));
}(this, (function (exports, i0, common, rxjs, operators) { 'use strict';

    var VgStates = /** @class */ (function () {
        function VgStates() {
        }
        return VgStates;
    }());
    VgStates.VG_ENDED = 'ended';
    VgStates.VG_PAUSED = 'paused';
    VgStates.VG_PLAYING = 'playing';
    VgStates.VG_LOADING = 'waiting';
    VgStates.decorators = [
        { type: i0.Injectable }
    ];

    var VgAPI = /** @class */ (function () {
        function VgAPI() {
            // tslint:disable-next-line:ban-types
            this.medias = {}; // TODO: refactor to Set<IPlayable>
            this.playerReadyEvent = new i0.EventEmitter(true);
            this.isPlayerReady = false;
        }
        VgAPI.prototype.onPlayerReady = function (fsAPI) {
            this.fsAPI = fsAPI;
            this.isPlayerReady = true;
            this.playerReadyEvent.emit(this);
        };
        VgAPI.prototype.getDefaultMedia = function () {
            for (var item in this.medias) {
                if (this.medias[item]) {
                    return this.medias[item];
                }
            }
        };
        VgAPI.prototype.getMasterMedia = function () {
            var master;
            for (var id in this.medias) {
                if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {
                    master = this.medias[id];
                    break;
                }
            }
            return master || this.getDefaultMedia();
        };
        VgAPI.prototype.isMasterDefined = function () {
            var result = false;
            for (var id in this.medias) {
                if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {
                    result = true;
                    break;
                }
            }
            return result;
        };
        VgAPI.prototype.getMediaById = function (id) {
            if (id === void 0) { id = null; }
            var media = this.medias[id];
            if (!id || id === '*') {
                media = this;
            }
            return media;
        };
        VgAPI.prototype.play = function () {
            for (var id in this.medias) {
                if (this.medias[id]) {
                    this.medias[id].play();
                }
            }
        };
        VgAPI.prototype.pause = function () {
            for (var id in this.medias) {
                if (this.medias[id]) {
                    this.medias[id].pause();
                }
            }
        };
        Object.defineProperty(VgAPI.prototype, "duration", {
            get: function () {
                return this.$$getAllProperties('duration');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "currentTime", {
            get: function () {
                return this.$$getAllProperties('currentTime');
            },
            set: function (seconds) {
                this.$$setAllProperties('currentTime', seconds);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "state", {
            get: function () {
                return this.$$getAllProperties('state');
            },
            set: function (state) {
                this.$$setAllProperties('state', state);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "volume", {
            get: function () {
                return this.$$getAllProperties('volume');
            },
            set: function (volume) {
                this.$$setAllProperties('volume', volume);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "playbackRate", {
            get: function () {
                return this.$$getAllProperties('playbackRate');
            },
            set: function (rate) {
                this.$$setAllProperties('playbackRate', rate);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "canPlay", {
            get: function () {
                return this.$$getAllProperties('canPlay');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "canPlayThrough", {
            get: function () {
                return this.$$getAllProperties('canPlayThrough');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "isMetadataLoaded", {
            get: function () {
                return this.$$getAllProperties('isMetadataLoaded');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "isWaiting", {
            get: function () {
                return this.$$getAllProperties('isWaiting');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "isCompleted", {
            get: function () {
                return this.$$getAllProperties('isCompleted');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "isLive", {
            get: function () {
                return this.$$getAllProperties('isLive');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "isMaster", {
            get: function () {
                return this.$$getAllProperties('isMaster');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "time", {
            get: function () {
                return this.$$getAllProperties('time');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "buffer", {
            get: function () {
                return this.$$getAllProperties('buffer');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "buffered", {
            get: function () {
                return this.$$getAllProperties('buffered');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "subscriptions", {
            get: function () {
                return this.$$getAllProperties('subscriptions');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgAPI.prototype, "textTracks", {
            get: function () {
                return this.$$getAllProperties('textTracks');
            },
            enumerable: false,
            configurable: true
        });
        VgAPI.prototype.seekTime = function (value, byPercent) {
            if (byPercent === void 0) { byPercent = false; }
            for (var id in this.medias) {
                if (this.medias[id]) {
                    this.$$seek(this.medias[id], value, byPercent);
                }
            }
        };
        VgAPI.prototype.$$seek = function (media, value, byPercent) {
            if (byPercent === void 0) { byPercent = false; }
            var second;
            var duration = media.duration;
            if (byPercent) {
                if (this.isMasterDefined()) {
                    duration = this.getMasterMedia().duration;
                }
                second = value * duration / 100;
            }
            else {
                second = value;
            }
            media.currentTime = second;
        };
        VgAPI.prototype.addTextTrack = function (type, label, language) {
            for (var id in this.medias) {
                if (this.medias[id]) {
                    this.$$addTextTrack(this.medias[id], type, label, language);
                }
            }
        };
        VgAPI.prototype.$$addTextTrack = function (media, type, label, language) {
            media.addTextTrack(type, label, language);
        };
        VgAPI.prototype.$$getAllProperties = function (property) {
            var medias = {};
            var result;
            for (var id in this.medias) {
                if (this.medias[id]) {
                    medias[id] = this.medias[id];
                }
            }
            var nMedias = Object.keys(medias).length;
            switch (nMedias) {
                case 0:
                    // Return default values until vgMedia is initialized
                    switch (property) {
                        case 'state':
                            result = VgStates.VG_PAUSED;
                            break;
                        case 'playbackRate':
                        case 'volume':
                            result = 1;
                            break;
                        case 'time':
                            result = { current: 0, total: 0, left: 0 };
                            break;
                    }
                    break;
                case 1:
                    // If there's only one media element then return the plain value
                    var firstMediaId = Object.keys(medias)[0];
                    result = medias[firstMediaId][property];
                    break;
                default:
                    // TODO: return 'master' value
                    var master = this.getMasterMedia();
                    result = medias[master.id][property];
            }
            return result;
        };
        VgAPI.prototype.$$setAllProperties = function (property, value) {
            for (var id in this.medias) {
                if (this.medias[id]) {
                    this.medias[id][property] = value;
                }
            }
        };
        VgAPI.prototype.registerElement = function (elem) {
            this.videogularElement = elem;
        };
        VgAPI.prototype.registerMedia = function (media) {
            this.medias[media.id] = media;
        };
        VgAPI.prototype.unregisterMedia = function (media) {
            delete this.medias[media.id];
        };
        return VgAPI;
    }());
    VgAPI.decorators = [
        { type: i0.Injectable }
    ];
    VgAPI.ctorParameters = function () { return []; };

    // tslint:disable:component-class-suffix
    var VgBuffering = /** @class */ (function () {
        function VgBuffering(ref, API) {
            this.API = API;
            this.checkInterval = 50;
            this.currentPlayPos = 0;
            this.lastPlayPos = 0;
            this.subscriptions = [];
            this.isBuffering = false;
            this.elem = ref.nativeElement;
        }
        VgBuffering.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgBuffering.prototype.onPlayerReady = function () {
            var _this = this;
            this.target = this.API.getMediaById(this.vgFor);
            this.subscriptions.push(this.target.subscriptions.bufferDetected.subscribe(function (isBuffering) { return _this.onUpdateBuffer(isBuffering); }));
        };
        VgBuffering.prototype.onUpdateBuffer = function (isBuffering) {
            this.isBuffering = isBuffering;
        };
        VgBuffering.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgBuffering;
    }());
    VgBuffering.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-buffering',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "<div class=\"vg-buffering\">\n            <div class=\"bufferingContainer\">\n                <div class=\"loadingSpinner\"></div>\n            </div>\n        </div>",
                    styles: ["\n        vg-buffering {\n            display: none;\n            z-index: 201;\n        }\n        vg-buffering.is-buffering {\n            display: block;\n        }\n\n        .vg-buffering {\n            position: absolute;\n            display: block;\n            width: 100%;\n            height: 100%;\n        }\n        .vg-buffering .bufferingContainer {\n            width: 100%;\n            position: absolute;\n            cursor: pointer;\n            top: 50%;\n            margin-top: -50px;\n            zoom: 1;\n            filter: alpha(opacity=60);\n            opacity: 0.6;\n        }\n        /* Loading Spinner\n        * http://www.alessioatzeni.com/blog/css3-loading-animation-loop/\n        */\n        .vg-buffering .loadingSpinner {\n            background-color: rgba(0, 0, 0, 0);\n            border: 5px solid rgba(255, 255, 255, 1);\n            opacity: .9;\n            border-top: 5px solid rgba(0, 0, 0, 0);\n            border-left: 5px solid rgba(0, 0, 0, 0);\n            border-radius: 50px;\n            box-shadow: 0 0 35px #FFFFFF;\n            width: 50px;\n            height: 50px;\n            margin: 0 auto;\n            -moz-animation: spin .5s infinite linear;\n            -webkit-animation: spin .5s infinite linear;\n        }\n        .vg-buffering .loadingSpinner .stop {\n            -webkit-animation-play-state: paused;\n            -moz-animation-play-state: paused;\n        }\n        @-moz-keyframes spin {\n            0% {\n                -moz-transform: rotate(0deg);\n            }\n            100% {\n                -moz-transform: rotate(360deg);\n            }\n        }\n        @-moz-keyframes spinoff {\n            0% {\n                -moz-transform: rotate(0deg);\n            }\n            100% {\n                -moz-transform: rotate(-360deg);\n            }\n        }\n        @-webkit-keyframes spin {\n            0% {\n                -webkit-transform: rotate(0deg);\n            }\n            100% {\n                -webkit-transform: rotate(360deg);\n            }\n        }\n        @-webkit-keyframes spinoff {\n            0% {\n                -webkit-transform: rotate(0deg);\n            }\n            100% {\n                -webkit-transform: rotate(-360deg);\n            }\n        }\n    "]
                },] }
    ];
    VgBuffering.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgBuffering.propDecorators = {
        vgFor: [{ type: i0.Input }],
        isBuffering: [{ type: i0.HostBinding, args: ['class.is-buffering',] }]
    };

    var VgBufferingModule = /** @class */ (function () {
        function VgBufferingModule() {
        }
        return VgBufferingModule;
    }());
    VgBufferingModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [
                        VgBuffering
                    ],
                    exports: [
                        VgBuffering
                    ]
                },] }
    ];

    var VgControlsHidden = /** @class */ (function () {
        function VgControlsHidden() {
            this.isHiddenSubject = new rxjs.Subject();
            this.isHidden = this.isHiddenSubject.asObservable();
        }
        VgControlsHidden.prototype.state = function (hidden) {
            this.isHiddenSubject.next(hidden);
        };
        return VgControlsHidden;
    }());
    VgControlsHidden.decorators = [
        { type: i0.Injectable }
    ];
    VgControlsHidden.ctorParameters = function () { return []; };

    // tslint:disable:component-class-suffix
    var VgControls = /** @class */ (function () {
        function VgControls(API, ref, hidden) {
            this.API = API;
            this.ref = ref;
            this.hidden = hidden;
            this.isAdsPlaying = 'initial';
            this.hideControls = false;
            this.vgAutohide = false;
            this.vgAutohideTime = 3;
            this.subscriptions = [];
            this.elem = ref.nativeElement;
        }
        VgControls.prototype.ngOnInit = function () {
            var _this = this;
            this.mouseMove$ = rxjs.fromEvent(this.API.videogularElement, 'mousemove');
            this.subscriptions.push(this.mouseMove$.subscribe(this.show.bind(this)));
            this.touchStart$ = rxjs.fromEvent(this.API.videogularElement, 'touchstart');
            this.subscriptions.push(this.touchStart$.subscribe(this.show.bind(this)));
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgControls.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
            this.subscriptions.push(this.target.subscriptions.play.subscribe(this.onPlay.bind(this)));
            this.subscriptions.push(this.target.subscriptions.pause.subscribe(this.onPause.bind(this)));
            this.subscriptions.push(this.target.subscriptions.startAds.subscribe(this.onStartAds.bind(this)));
            this.subscriptions.push(this.target.subscriptions.endAds.subscribe(this.onEndAds.bind(this)));
        };
        VgControls.prototype.ngAfterViewInit = function () {
            if (this.vgAutohide) {
                this.hide();
            }
            else {
                this.show();
            }
        };
        VgControls.prototype.onPlay = function () {
            if (this.vgAutohide) {
                this.hide();
            }
        };
        VgControls.prototype.onPause = function () {
            clearTimeout(this.timer);
            this.hideControls = false;
            this.hidden.state(false);
        };
        VgControls.prototype.onStartAds = function () {
            this.isAdsPlaying = 'none';
        };
        VgControls.prototype.onEndAds = function () {
            this.isAdsPlaying = 'initial';
        };
        VgControls.prototype.hide = function () {
            if (this.vgAutohide) {
                clearTimeout(this.timer);
                this.hideAsync();
            }
        };
        VgControls.prototype.show = function () {
            clearTimeout(this.timer);
            this.hideControls = false;
            this.hidden.state(false);
            if (this.vgAutohide) {
                this.hideAsync();
            }
        };
        VgControls.prototype.hideAsync = function () {
            var _this = this;
            if (this.API.state === VgStates.VG_PLAYING) {
                this.timer = setTimeout(function () {
                    _this.hideControls = true;
                    _this.hidden.state(true);
                }, this.vgAutohideTime * 1000);
            }
        };
        VgControls.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgControls;
    }());
    VgControls.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-controls',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "<ng-content></ng-content>",
                    styles: ["\n        vg-controls {\n            position: absolute;\n            display: flex;\n            width: 100%;\n            height: 50px;\n            z-index: 300;\n            bottom: 0;\n            background-color: rgba(0, 0, 0, 0.5);\n            -webkit-transition: bottom 1s;\n            -khtml-transition: bottom 1s;\n            -moz-transition: bottom 1s;\n            -ms-transition: bottom 1s;\n            transition: bottom 1s;\n        }\n        vg-controls.hide {\n            bottom: -50px;\n        }\n    "]
                },] }
    ];
    VgControls.ctorParameters = function () { return [
        { type: VgAPI },
        { type: i0.ElementRef },
        { type: VgControlsHidden }
    ]; };
    VgControls.propDecorators = {
        isAdsPlaying: [{ type: i0.HostBinding, args: ['style.pointer-events',] }],
        hideControls: [{ type: i0.HostBinding, args: ['class.hide',] }],
        vgFor: [{ type: i0.Input }],
        vgAutohide: [{ type: i0.Input }],
        vgAutohideTime: [{ type: i0.Input }]
    };

    var VgUtils = /** @class */ (function () {
        function VgUtils() {
        }
        /**
         * Inspired by Paul Irish
         * https://gist.github.com/paulirish/211209
         * @returns z-Index
         */
        VgUtils.getZIndex = function () {
            var zIndex = 1;
            var elementZIndex;
            var tags = document.getElementsByTagName('*');
            for (var i = 0, l = tags.length; i < l; i++) {
                elementZIndex = parseInt(window.getComputedStyle(tags[i])['z-index'], 10);
                if (elementZIndex > zIndex) {
                    zIndex = elementZIndex + 1;
                }
            }
            return zIndex;
        };
        // Very simple mobile detection, not 100% reliable
        VgUtils.isMobileDevice = function () {
            return (typeof window.orientation !== 'undefined') || (navigator.userAgent.indexOf('IEMobile') !== -1);
        };
        VgUtils.isiOSDevice = function () {
            return (navigator.userAgent.match(/ip(hone|ad|od)/i) && !navigator.userAgent.match(/(iemobile)[\/\s]?([\w\.]*)/i));
        };
        VgUtils.isCordova = function () {
            return document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;
        };
        return VgUtils;
    }());
    VgUtils.ɵprov = i0.ɵɵdefineInjectable({ factory: function VgUtils_Factory() { return new VgUtils(); }, token: VgUtils, providedIn: "root" });
    VgUtils.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];

    var VgFullscreenAPI = /** @class */ (function () {
        function VgFullscreenAPI() {
            this.nativeFullscreen = true;
            this.isFullscreen = false;
            this.onChangeFullscreen = new i0.EventEmitter();
        }
        VgFullscreenAPI.prototype.init = function (elem, medias) {
            var _this = this;
            this.videogularElement = elem;
            this.medias = medias;
            var APIs = {
                w3: {
                    enabled: 'fullscreenEnabled',
                    element: 'fullscreenElement',
                    request: 'requestFullscreen',
                    exit: 'exitFullscreen',
                    onchange: 'fullscreenchange',
                    onerror: 'fullscreenerror'
                },
                newWebkit: {
                    enabled: 'webkitFullscreenEnabled',
                    element: 'webkitFullscreenElement',
                    request: 'webkitRequestFullscreen',
                    exit: 'webkitExitFullscreen',
                    onchange: 'webkitfullscreenchange',
                    onerror: 'webkitfullscreenerror'
                },
                oldWebkit: {
                    enabled: 'webkitIsFullScreen',
                    element: 'webkitCurrentFullScreenElement',
                    request: 'webkitRequestFullScreen',
                    exit: 'webkitCancelFullScreen',
                    onchange: 'webkitfullscreenchange',
                    onerror: 'webkitfullscreenerror'
                },
                moz: {
                    enabled: 'mozFullScreen',
                    element: 'mozFullScreenElement',
                    request: 'mozRequestFullScreen',
                    exit: 'mozCancelFullScreen',
                    onchange: 'mozfullscreenchange',
                    onerror: 'mozfullscreenerror'
                },
                ios: {
                    enabled: 'webkitFullscreenEnabled',
                    element: 'webkitFullscreenElement',
                    request: 'webkitEnterFullscreen',
                    exit: 'webkitExitFullscreen',
                    onchange: 'webkitendfullscreen',
                    onerror: 'webkitfullscreenerror'
                },
                ms: {
                    enabled: 'msFullscreenEnabled',
                    element: 'msFullscreenElement',
                    request: 'msRequestFullscreen',
                    exit: 'msExitFullscreen',
                    onchange: 'MSFullscreenChange',
                    onerror: 'MSFullscreenError'
                }
            };
            for (var browser in APIs) {
                if (APIs[browser].enabled in document) {
                    this.polyfill = APIs[browser];
                    break;
                }
            }
            if (VgUtils.isiOSDevice()) {
                this.polyfill = APIs.ios;
            }
            this.isAvailable = (this.polyfill != null);
            if (this.polyfill == null) {
                return;
            }
            var fsElemDispatcher;
            switch (this.polyfill.onchange) {
                // Mozilla dispatches the fullscreen change event from document, not the element
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=724816#c3
                case 'mozfullscreenchange':
                    fsElemDispatcher = document;
                    break;
                // iOS dispatches the fullscreen change event from video element
                case 'webkitendfullscreen':
                    fsElemDispatcher = this.medias.toArray()[0].elem;
                    break;
                // HTML5 implementation dispatches the fullscreen change event from the element
                default:
                    fsElemDispatcher = elem;
            }
            this.fsChangeSubscription = rxjs.fromEvent(fsElemDispatcher, this.polyfill.onchange).subscribe(function () {
                _this.onFullscreenChange();
            });
        };
        VgFullscreenAPI.prototype.onFullscreenChange = function () {
            this.isFullscreen = !!document[this.polyfill.element];
            this.onChangeFullscreen.emit(this.isFullscreen);
        };
        VgFullscreenAPI.prototype.toggleFullscreen = function (element) {
            if (element === void 0) { element = null; }
            if (this.isFullscreen) {
                this.exit();
            }
            else {
                this.request(element);
            }
        };
        VgFullscreenAPI.prototype.request = function (elem) {
            if (!elem) {
                elem = this.videogularElement;
            }
            this.isFullscreen = true;
            this.onChangeFullscreen.emit(true);
            // Perform native full screen support
            if (this.isAvailable && this.nativeFullscreen) {
                // Fullscreen for mobile devices
                if (VgUtils.isMobileDevice()) {
                    // We should make fullscreen the video object if it doesn't have native fullscreen support
                    // Fallback! We can't set vg-player on fullscreen, only video/audio objects
                    if ((!this.polyfill.enabled && elem === this.videogularElement) || VgUtils.isiOSDevice()) {
                        elem = this.medias.toArray()[0].elem;
                    }
                    this.enterElementInFullScreen(elem);
                }
                else {
                    this.enterElementInFullScreen(this.videogularElement);
                }
            }
        };
        VgFullscreenAPI.prototype.enterElementInFullScreen = function (elem) {
            elem[this.polyfill.request]();
        };
        VgFullscreenAPI.prototype.exit = function () {
            this.isFullscreen = false;
            this.onChangeFullscreen.emit(false);
            // Exit from native fullscreen
            if (this.isAvailable && this.nativeFullscreen) {
                document[this.polyfill.exit]();
            }
        };
        return VgFullscreenAPI;
    }());
    VgFullscreenAPI.decorators = [
        { type: i0.Injectable }
    ];
    VgFullscreenAPI.ctorParameters = function () { return []; };

    // tslint:disable:component-class-suffix
    // tslint:disable:ban-types
    var VgFullscreen = /** @class */ (function () {
        function VgFullscreen(ref, API, fsAPI) {
            this.API = API;
            this.fsAPI = fsAPI;
            this.isFullscreen = false;
            this.subscriptions = [];
            this.ariaValue = 'normal mode';
            this.elem = ref.nativeElement;
            this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));
        }
        VgFullscreen.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgFullscreen.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
        };
        VgFullscreen.prototype.onChangeFullscreen = function (fsState) {
            this.ariaValue = fsState ? 'fullscren mode' : 'normal mode';
            this.isFullscreen = fsState;
        };
        VgFullscreen.prototype.onClick = function () {
            this.changeFullscreenState();
        };
        VgFullscreen.prototype.onKeyDown = function (event) {
            // On press Enter (13) or Space (32)
            if (event.keyCode === 13 || event.keyCode === 32) {
                event.preventDefault();
                this.changeFullscreenState();
            }
        };
        VgFullscreen.prototype.changeFullscreenState = function () {
            var element = this.target;
            if (this.target instanceof VgAPI) {
                element = null;
            }
            this.fsAPI.toggleFullscreen(element);
        };
        VgFullscreen.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgFullscreen;
    }());
    VgFullscreen.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-fullscreen',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div class=\"icon\"\n             [class.vg-icon-fullscreen]=\"!isFullscreen\"\n             [class.vg-icon-fullscreen_exit]=\"isFullscreen\"\n             tabindex=\"0\"\n             role=\"button\"\n             aria-label=\"fullscreen button\"\n             [attr.aria-valuetext]=\"ariaValue\">\n        </div>",
                    styles: ["\n        vg-fullscreen {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -khtml-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n\n        vg-fullscreen .icon {\n            pointer-events: none;\n        }\n    "]
                },] }
    ];
    VgFullscreen.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI },
        { type: VgFullscreenAPI }
    ]; };
    VgFullscreen.propDecorators = {
        onClick: [{ type: i0.HostListener, args: ['click',] }],
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    // tslint:disable:component-class-suffix
    var VgMute = /** @class */ (function () {
        function VgMute(ref, API) {
            this.API = API;
            this.subscriptions = [];
            this.ariaValue = 'unmuted';
            this.elem = ref.nativeElement;
        }
        VgMute.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgMute.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
            this.currentVolume = this.target.volume;
        };
        VgMute.prototype.onClick = function () {
            this.changeMuteState();
        };
        VgMute.prototype.onKeyDown = function (event) {
            // On press Enter (13) or Space (32)
            if (event.keyCode === 13 || event.keyCode === 32) {
                event.preventDefault();
                this.changeMuteState();
            }
        };
        VgMute.prototype.changeMuteState = function () {
            var volume = this.getVolume();
            if (volume === 0) {
                if (this.target.volume === 0 && this.currentVolume === 0) {
                    this.currentVolume = 1;
                }
                this.target.volume = this.currentVolume;
            }
            else {
                this.currentVolume = volume;
                this.target.volume = 0;
            }
        };
        VgMute.prototype.getVolume = function () {
            var volume = this.target ? this.target.volume : 0;
            this.ariaValue = volume ? 'unmuted' : 'muted';
            return volume;
        };
        VgMute.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgMute;
    }());
    VgMute.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-mute',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div class=\"icon\"\n             [class.vg-icon-volume_up]=\"getVolume() >= 0.75\"\n             [class.vg-icon-volume_down]=\"getVolume() >= 0.25 && getVolume() < 0.75\"\n             [class.vg-icon-volume_mute]=\"getVolume() > 0 && getVolume() < 0.25\"\n             [class.vg-icon-volume_off]=\"getVolume() === 0\"\n             tabindex=\"0\"\n             role=\"button\"\n             aria-label=\"mute button\"\n             [attr.aria-valuetext]=\"ariaValue\">\n        </div>",
                    styles: ["\n        vg-mute {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -khtml-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-mute .icon {\n            pointer-events: none;\n        }\n    "]
                },] }
    ];
    VgMute.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgMute.propDecorators = {
        vgFor: [{ type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ['click',] }],
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    // tslint:disable:component-class-suffix
    var VgVolume = /** @class */ (function () {
        function VgVolume(ref, API) {
            this.API = API;
            this.subscriptions = [];
            this.elem = ref.nativeElement;
            this.isDragging = false;
        }
        VgVolume.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgVolume.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
            this.ariaValue = this.getVolume() * 100;
        };
        VgVolume.prototype.onClick = function (event) {
            this.setVolume(this.calculateVolume(event.clientX));
        };
        VgVolume.prototype.onMouseDown = function (event) {
            this.mouseDownPosX = event.clientX;
            this.isDragging = true;
        };
        VgVolume.prototype.onDrag = function (event) {
            if (this.isDragging) {
                this.setVolume(this.calculateVolume(event.clientX));
            }
        };
        VgVolume.prototype.onStopDrag = function (event) {
            if (this.isDragging) {
                this.isDragging = false;
                if (this.mouseDownPosX === event.clientX) {
                    this.setVolume(this.calculateVolume(event.clientX));
                }
            }
        };
        VgVolume.prototype.arrowAdjustVolume = function (event) {
            if (event.keyCode === 38 || event.keyCode === 39) {
                event.preventDefault();
                this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 + 10)));
            }
            else if (event.keyCode === 37 || event.keyCode === 40) {
                event.preventDefault();
                this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 - 10)));
            }
        };
        VgVolume.prototype.calculateVolume = function (mousePosX) {
            var recObj = this.volumeBarRef.nativeElement.getBoundingClientRect();
            var volumeBarOffsetLeft = recObj.left;
            var volumeBarWidth = recObj.width;
            return (mousePosX - volumeBarOffsetLeft) / volumeBarWidth * 100;
        };
        VgVolume.prototype.setVolume = function (vol) {
            this.target.volume = Math.max(0, Math.min(1, vol / 100));
            this.ariaValue = this.target.volume * 100;
        };
        VgVolume.prototype.getVolume = function () {
            return this.target ? this.target.volume : 0;
        };
        VgVolume.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgVolume;
    }());
    VgVolume.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-volume',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div\n            #volumeBar\n            class=\"volumeBar\"\n            tabindex=\"0\"\n            role=\"slider\"\n            aria-label=\"volume level\"\n            aria-level=\"polite\"\n            [attr.aria-valuenow]=\"ariaValue\"\n            aria-valuemin=\"0\"\n            aria-valuemax=\"100\"\n            aria-orientation=\"horizontal\"\n            [attr.aria-valuetext]=\"ariaValue + '%'\"\n            (click)=\"onClick($event)\"\n            (mousedown)=\"onMouseDown($event)\">\n            <div class=\"volumeBackground\" [ngClass]=\"{dragging: isDragging}\">\n                <div class=\"volumeValue\" [style.width]=\"(getVolume() * (100-15)) + '%'\"></div>\n                <div class=\"volumeKnob\" [style.left]=\"(getVolume() * (100-15)) + '%'\"></div>\n            </div>\n        </div>\n    ",
                    styles: ["\n        vg-volume {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 100px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-volume .volumeBar {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n        }\n        vg-volume .volumeBackground {\n            display: flex;\n            flex-grow: 1;\n            height: 5px;\n            pointer-events: none;\n            background-color: #333;\n        }\n        vg-volume .volumeValue {\n            display: flex;\n            height: 5px;\n            pointer-events: none;\n            background-color: #FFF;\n            transition:all 0.2s ease-out;\n        }\n        vg-volume .volumeKnob {\n            position: absolute;\n            width: 15px; height: 15px;\n            left: 0; top: 50%;\n            transform: translateY(-50%);\n            border-radius: 15px;\n            pointer-events: none;\n            background-color: #FFF;\n            transition:all 0.2s ease-out;\n        }\n        vg-volume .volumeBackground.dragging .volumeValue,\n        vg-volume .volumeBackground.dragging .volumeKnob {\n            transition: none;\n        }\n    "]
                },] }
    ];
    VgVolume.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgVolume.propDecorators = {
        vgFor: [{ type: i0.Input }],
        volumeBarRef: [{ type: i0.ViewChild, args: ['volumeBar', { static: true },] }],
        onDrag: [{ type: i0.HostListener, args: ['document:mousemove', ['$event'],] }],
        onStopDrag: [{ type: i0.HostListener, args: ['document:mouseup', ['$event'],] }],
        arrowAdjustVolume: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    // tslint:disable:component-class-suffix
    var VgPlayPause = /** @class */ (function () {
        function VgPlayPause(ref, API) {
            this.API = API;
            this.subscriptions = [];
            this.ariaValue = VgStates.VG_PAUSED;
            this.elem = ref.nativeElement;
        }
        VgPlayPause.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgPlayPause.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
        };
        VgPlayPause.prototype.onClick = function () {
            this.playPause();
        };
        VgPlayPause.prototype.onKeyDown = function (event) {
            // On press Enter (13) or Space (32)
            if (event.keyCode === 13 || event.keyCode === 32) {
                event.preventDefault();
                this.playPause();
            }
        };
        VgPlayPause.prototype.playPause = function () {
            var state = this.getState();
            switch (state) {
                case VgStates.VG_PLAYING:
                    this.target.pause();
                    break;
                case VgStates.VG_PAUSED:
                case VgStates.VG_ENDED:
                    this.target.play();
                    break;
            }
        };
        VgPlayPause.prototype.getState = function () {
            this.ariaValue = this.target ? this.target.state : VgStates.VG_PAUSED;
            return this.ariaValue;
        };
        VgPlayPause.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgPlayPause;
    }());
    VgPlayPause.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-play-pause',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div class=\"icon\"\n             [class.vg-icon-pause]=\"getState() === 'playing'\"\n             [class.vg-icon-play_arrow]=\"getState() === 'paused' || getState() === 'ended'\"\n             tabindex=\"0\"\n             role=\"button\"\n             [attr.aria-label]=\"getState() === 'paused'?'play':'pause'\"\n             [attr.aria-valuetext]=\"ariaValue\">\n        </div>",
                    styles: ["\n        vg-play-pause {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -khtml-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-play-pause .icon {\n            pointer-events: none;\n        }\n    "]
                },] }
    ];
    VgPlayPause.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgPlayPause.propDecorators = {
        vgFor: [{ type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ['click',] }],
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    // tslint:disable:component-class-suffix
    var VgPlaybackButton = /** @class */ (function () {
        function VgPlaybackButton(ref, API) {
            this.API = API;
            this.subscriptions = [];
            this.ariaValue = 1;
            this.elem = ref.nativeElement;
            this.playbackValues = ['0.5', '1.0', '1.5', '2.0'];
            this.playbackIndex = 1;
        }
        VgPlaybackButton.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgPlaybackButton.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
        };
        VgPlaybackButton.prototype.onClick = function () {
            this.updatePlaybackSpeed();
        };
        VgPlaybackButton.prototype.onKeyDown = function (event) {
            // On press Enter (13) or Space (32)
            if (event.keyCode === 13 || event.keyCode === 32) {
                event.preventDefault();
                this.updatePlaybackSpeed();
            }
        };
        VgPlaybackButton.prototype.updatePlaybackSpeed = function () {
            this.playbackIndex = ++this.playbackIndex % this.playbackValues.length;
            if (this.target instanceof VgAPI) {
                this.target.playbackRate = (this.playbackValues[this.playbackIndex]);
            }
            else {
                this.target.playbackRate[this.vgFor] = (this.playbackValues[this.playbackIndex]);
            }
        };
        VgPlaybackButton.prototype.getPlaybackRate = function () {
            this.ariaValue = this.target ? this.target.playbackRate : 1.0;
            return this.ariaValue;
        };
        VgPlaybackButton.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgPlaybackButton;
    }());
    VgPlaybackButton.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-playback-button',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n    <span class=\"button\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"playback speed button\"\n          [attr.aria-valuetext]=\"ariaValue\">\n        {{getPlaybackRate()}}x\n    </span>",
                    styles: ["\n        vg-playback-button {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n        }\n        vg-playback-button .button {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            width: 50px;\n        }\n    "]
                },] }
    ];
    VgPlaybackButton.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgPlaybackButton.propDecorators = {
        vgFor: [{ type: i0.Input }],
        playbackValues: [{ type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ['click',] }],
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    // tslint:disable:component-class-suffix
    var VgScrubBar = /** @class */ (function () {
        function VgScrubBar(ref, API, vgControlsHiddenState) {
            var _this = this;
            this.API = API;
            this.hideScrubBar = false;
            this.vgSlider = true;
            this.isSeeking = false;
            this.wasPlaying = false;
            this.subscriptions = [];
            this.elem = ref.nativeElement;
            this.subscriptions.push(vgControlsHiddenState.isHidden.subscribe(function (hide) { return _this.onHideScrubBar(hide); }));
        }
        VgScrubBar.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgScrubBar.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
        };
        VgScrubBar.prototype.seekStart = function () {
            if (this.target.canPlay) {
                this.isSeeking = true;
                if (this.target.state === VgStates.VG_PLAYING) {
                    this.wasPlaying = true;
                }
                this.target.pause();
            }
        };
        VgScrubBar.prototype.seekMove = function (offset) {
            if (this.isSeeking) {
                var percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);
                this.target.time.current = percentage * this.target.time.total / 100;
                this.target.seekTime(percentage, true);
            }
        };
        VgScrubBar.prototype.seekEnd = function (offset) {
            this.isSeeking = false;
            if (this.target.canPlay) {
                var percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);
                this.target.seekTime(percentage, true);
                if (this.wasPlaying) {
                    this.wasPlaying = false;
                    this.target.play();
                }
            }
        };
        VgScrubBar.prototype.touchEnd = function () {
            this.isSeeking = false;
            if (this.wasPlaying) {
                this.wasPlaying = false;
                this.target.play();
            }
        };
        VgScrubBar.prototype.getTouchOffset = function (event) {
            var offsetLeft = 0;
            var element = event.target;
            while (element) {
                offsetLeft += element.offsetLeft;
                element = element.offsetParent;
            }
            return event.touches[0].pageX - offsetLeft;
        };
        VgScrubBar.prototype.onMouseDownScrubBar = function ($event) {
            if (this.target) {
                if (!this.target.isLive) {
                    if (!this.vgSlider) {
                        this.seekEnd($event.offsetX);
                    }
                    else {
                        this.seekStart();
                    }
                }
            }
        };
        VgScrubBar.prototype.onMouseMoveScrubBar = function ($event) {
            if (this.target) {
                if (!this.target.isLive && this.vgSlider && this.isSeeking) {
                    this.seekMove($event.offsetX);
                }
            }
        };
        VgScrubBar.prototype.onMouseUpScrubBar = function ($event) {
            if (this.target) {
                if (!this.target.isLive && this.vgSlider && this.isSeeking) {
                    this.seekEnd($event.offsetX);
                }
            }
        };
        VgScrubBar.prototype.onTouchStartScrubBar = function ($event) {
            if (this.target) {
                if (!this.target.isLive) {
                    if (!this.vgSlider) {
                        this.seekEnd(this.getTouchOffset($event));
                    }
                    else {
                        this.seekStart();
                    }
                }
            }
        };
        VgScrubBar.prototype.onTouchMoveScrubBar = function ($event) {
            if (this.target) {
                if (!this.target.isLive && this.vgSlider && this.isSeeking) {
                    this.seekMove(this.getTouchOffset($event));
                }
            }
        };
        // @ts-ignore
        VgScrubBar.prototype.onTouchCancelScrubBar = function ($event) {
            if (this.target) {
                if (!this.target.isLive && this.vgSlider && this.isSeeking) {
                    this.touchEnd();
                }
            }
        };
        // @ts-ignore
        VgScrubBar.prototype.onTouchEndScrubBar = function ($event) {
            if (this.target) {
                if (!this.target.isLive && this.vgSlider && this.isSeeking) {
                    this.touchEnd();
                }
            }
        };
        VgScrubBar.prototype.arrowAdjustVolume = function (event) {
            if (this.target) {
                if (event.keyCode === 38 || event.keyCode === 39) {
                    event.preventDefault();
                    this.target.seekTime((this.target.time.current + 5000) / 1000, false);
                }
                else if (event.keyCode === 37 || event.keyCode === 40) {
                    event.preventDefault();
                    this.target.seekTime((this.target.time.current - 5000) / 1000, false);
                }
            }
        };
        VgScrubBar.prototype.getPercentage = function () {
            return this.target ? ((this.target.time.current * 100) / this.target.time.total) + '%' : '0%';
        };
        VgScrubBar.prototype.onHideScrubBar = function (hide) {
            this.hideScrubBar = hide;
        };
        VgScrubBar.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgScrubBar;
    }());
    VgScrubBar.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-scrub-bar',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div class=\"scrubBar\"\n             tabindex=\"0\"\n             role=\"slider\"\n             aria-label=\"scrub bar\"\n             aria-level=\"polite\"\n             [attr.aria-valuenow]=\"getPercentage()\"\n             aria-valuemin=\"0\"\n             aria-valuemax=\"100\"\n             [attr.aria-valuetext]=\"getPercentage() + '%'\">\n            <ng-content></ng-content>\n        </div>\n    ",
                    styles: ["\n        vg-scrub-bar {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            position: absolute;\n            width: 100%;\n            height: 5px;\n            bottom: 50px;\n            margin: 0;\n            cursor: pointer;\n            align-items: center;\n            background: rgba(0, 0, 0, 0.75);\n            z-index: 250;\n            -webkit-transition: bottom 1s, opacity 0.5s;\n            -khtml-transition: bottom 1s, opacity 0.5s;\n            -moz-transition: bottom 1s, opacity 0.5s;\n            -ms-transition: bottom 1s, opacity 0.5s;\n            transition: bottom 1s, opacity 0.5s;\n        }\n        vg-scrub-bar .scrubBar {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n            height: 100%;\n        }\n        vg-controls vg-scrub-bar {\n            position: relative;\n            bottom: 0;\n            background: transparent;\n            height: 50px;\n            flex-grow: 1;\n            flex-basis: 0;\n            margin: 0 10px;\n            -webkit-transition: initial;\n            -khtml-transition: initial;\n            -moz-transition: initial;\n            -ms-transition: initial;\n            transition: initial;\n        }\n        vg-scrub-bar.hide {\n            bottom: 0;\n            opacity: 0;\n        }\n        vg-controls vg-scrub-bar.hide {\n            bottom: initial;\n            opacity: initial;\n        }\n    "]
                },] }
    ];
    VgScrubBar.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI },
        { type: VgControlsHidden }
    ]; };
    VgScrubBar.propDecorators = {
        hideScrubBar: [{ type: i0.HostBinding, args: ['class.hide',] }],
        vgFor: [{ type: i0.Input }],
        vgSlider: [{ type: i0.Input }],
        onMouseDownScrubBar: [{ type: i0.HostListener, args: ['mousedown', ['$event'],] }],
        onMouseMoveScrubBar: [{ type: i0.HostListener, args: ['document:mousemove', ['$event'],] }],
        onMouseUpScrubBar: [{ type: i0.HostListener, args: ['document:mouseup', ['$event'],] }],
        onTouchStartScrubBar: [{ type: i0.HostListener, args: ['touchstart', ['$event'],] }],
        onTouchMoveScrubBar: [{ type: i0.HostListener, args: ['document:touchmove', ['$event'],] }],
        onTouchCancelScrubBar: [{ type: i0.HostListener, args: ['document:touchcancel', ['$event'],] }],
        onTouchEndScrubBar: [{ type: i0.HostListener, args: ['document:touchend', ['$event'],] }],
        arrowAdjustVolume: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    // tslint:disable:component-class-suffix
    var VgScrubBarBufferingTime = /** @class */ (function () {
        function VgScrubBarBufferingTime(ref, API) {
            this.API = API;
            this.subscriptions = [];
            this.elem = ref.nativeElement;
        }
        VgScrubBarBufferingTime.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgScrubBarBufferingTime.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
        };
        VgScrubBarBufferingTime.prototype.getBufferTime = function () {
            var bufferTime = '0%';
            if (this.target && this.target.buffer && this.target.buffered.length) {
                if (this.target.time.total === 0) {
                    bufferTime = '0%';
                }
                else {
                    bufferTime = ((this.target.buffer.end / this.target.time.total) * 100) + '%';
                }
            }
            return bufferTime;
        };
        VgScrubBarBufferingTime.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgScrubBarBufferingTime;
    }());
    VgScrubBarBufferingTime.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-scrub-bar-buffering-time',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "<div class=\"background\" [style.width]=\"getBufferTime()\"></div>",
                    styles: ["\n        vg-scrub-bar-buffering-time {\n            display: flex;\n            width: 100%;\n            height: 5px;\n            pointer-events: none;\n            position: absolute;\n        }\n        vg-scrub-bar-buffering-time .background {\n            background-color: rgba(255, 255, 255, 0.3);\n        }\n        vg-controls vg-scrub-bar-buffering-time {\n            position: absolute;\n            top: calc(50% - 3px);\n        }\n        vg-controls vg-scrub-bar-buffering-time .background {\n            -webkit-border-radius: 2px;\n            -moz-border-radius: 2px;\n            border-radius: 2px;\n        }\n    "]
                },] }
    ];
    VgScrubBarBufferingTime.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgScrubBarBufferingTime.propDecorators = {
        vgFor: [{ type: i0.Input }]
    };

    // tslint:disable:no-conflicting-lifecycle
    // tslint:disable:component-class-suffix
    // tslint:disable:no-string-literal
    var VgScrubBarCuePoints = /** @class */ (function () {
        function VgScrubBarCuePoints(ref, API) {
            this.API = API;
            this.onLoadedMetadataCalled = false;
            this.cuePoints = [];
            this.subscriptions = [];
            this.totalCues = 0;
            this.elem = ref.nativeElement;
        }
        VgScrubBarCuePoints.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgScrubBarCuePoints.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
            var onTimeUpdate = this.target.subscriptions.loadedMetadata;
            this.subscriptions.push(onTimeUpdate.subscribe(this.onLoadedMetadata.bind(this)));
            if (this.onLoadedMetadataCalled) {
                this.onLoadedMetadata();
            }
        };
        VgScrubBarCuePoints.prototype.onLoadedMetadata = function () {
            if (this.vgCuePoints) {
                // We need to transform the TextTrackCueList to Array or it doesn't work on IE11/Edge.
                // See: https://github.com/videogular/videogular2/issues/369
                this.cuePoints = [];
                for (var i = 0, l = this.vgCuePoints.length; i < l; i++) {
                    var end = (this.vgCuePoints[i].endTime >= 0) ? this.vgCuePoints[i].endTime : this.vgCuePoints[i].startTime + 1;
                    var cuePointDuration = (end - this.vgCuePoints[i].startTime) * 1000;
                    var position = '0';
                    var percentWidth = '0';
                    if (typeof cuePointDuration === 'number' && this.target.time.total) {
                        percentWidth = ((cuePointDuration * 100) / this.target.time.total) + '%';
                        position = (this.vgCuePoints[i].startTime * 100 / (Math.round(this.target.time.total / 1000))) + '%';
                    }
                    this.vgCuePoints[i].$$style = {
                        width: percentWidth,
                        left: position
                    };
                    this.cuePoints.push(this.vgCuePoints[i]);
                }
            }
        };
        VgScrubBarCuePoints.prototype.updateCuePoints = function () {
            if (!this.target) {
                this.onLoadedMetadataCalled = true;
                return;
            }
            this.onLoadedMetadata();
        };
        VgScrubBarCuePoints.prototype.ngOnChanges = function (changes) {
            if (changes['vgCuePoints'].currentValue) {
                this.updateCuePoints();
            }
        };
        VgScrubBarCuePoints.prototype.ngDoCheck = function () {
            if (this.vgCuePoints) {
                var changes = this.totalCues !== this.vgCuePoints.length;
                if (changes) {
                    this.totalCues = this.vgCuePoints.length;
                    this.updateCuePoints();
                }
            }
        };
        VgScrubBarCuePoints.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgScrubBarCuePoints;
    }());
    VgScrubBarCuePoints.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-scrub-bar-cue-points',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div class=\"cue-point-container\">\n            <span *ngFor=\"let cp of cuePoints\" [style.width]=\"cp.$$style?.width\" [style.left]=\"cp.$$style?.left\"\n                  class=\"cue-point\"></span>\n        </div>\n    ",
                    styles: ["\n        vg-scrub-bar-cue-points {\n            display: flex;\n            width: 100%;\n            height: 5px;\n            pointer-events: none;\n            position: absolute;\n        }\n        vg-scrub-bar-cue-points .cue-point-container .cue-point {\n            position: absolute;\n            height: 5px;\n            background-color: rgba(255, 204, 0, 0.7);\n        }\n        vg-controls vg-scrub-bar-cue-points {\n            position: absolute;\n            top: calc(50% - 3px);\n        }\n    "]
                },] }
    ];
    VgScrubBarCuePoints.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgScrubBarCuePoints.propDecorators = {
        vgCuePoints: [{ type: i0.Input }],
        vgFor: [{ type: i0.Input }]
    };

    // tslint:disable:component-class-suffix
    var VgScrubBarCurrentTime = /** @class */ (function () {
        function VgScrubBarCurrentTime(ref, API) {
            this.API = API;
            this.vgSlider = false;
            this.subscriptions = [];
            this.elem = ref.nativeElement;
        }
        VgScrubBarCurrentTime.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgScrubBarCurrentTime.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
        };
        VgScrubBarCurrentTime.prototype.getPercentage = function () {
            return this.target ? ((this.target.time.current * 100) / this.target.time.total) + '%' : '0%';
        };
        VgScrubBarCurrentTime.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgScrubBarCurrentTime;
    }());
    VgScrubBarCurrentTime.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-scrub-bar-current-time',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "<div class=\"background\" [style.width]=\"getPercentage()\"></div><span class=\"slider\" *ngIf=\"vgSlider\"></span>",
                    styles: ["\n        vg-scrub-bar-current-time {\n            display: flex;\n            width: 100%;\n            height: 5px;\n            pointer-events: none;\n            position: absolute;\n        }\n        vg-scrub-bar-current-time .background {\n            background-color: white;\n        }\n        vg-controls vg-scrub-bar-current-time {\n            position: absolute;\n            top: calc(50% - 3px);\n            -webkit-border-radius: 2px;\n            -moz-border-radius: 2px;\n            border-radius: 2px;\n        }\n        vg-controls vg-scrub-bar-current-time .background {\n            border: 1px solid white;\n            -webkit-border-radius: 2px;\n            -moz-border-radius: 2px;\n            border-radius: 2px;\n        }\n\n        vg-scrub-bar-current-time .slider{\n            background: white;\n            height: 15px;\n            width: 15px;\n            border-radius: 50%;\n            box-shadow: 0px 0px 10px black;\n            margin-top: -5px;\n            margin-left: -10px;\n        }\n    "]
                },] }
    ];
    VgScrubBarCurrentTime.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgScrubBarCurrentTime.propDecorators = {
        vgFor: [{ type: i0.Input }],
        vgSlider: [{ type: i0.Input }]
    };

    // Workaround until we can use UTC with Angular Date Pipe
    var VgUtcPipe = /** @class */ (function () {
        function VgUtcPipe() {
        }
        VgUtcPipe.prototype.transform = function (value, format) {
            var date = new Date(value);
            var result = format;
            var ss = date.getUTCSeconds();
            var mm = date.getUTCMinutes();
            var hh = date.getUTCHours();
            if (ss < 10) {
                ss = '0' + ss;
            }
            if (mm < 10) {
                mm = '0' + mm;
            }
            if (hh < 10) {
                hh = '0' + hh;
            }
            result = result.replace(/ss/g, ss);
            result = result.replace(/mm/g, mm);
            result = result.replace(/hh/g, hh);
            return result;
        };
        return VgUtcPipe;
    }());
    VgUtcPipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'vgUtc' },] }
    ];
    // tslint:disable:component-class-suffix
    var VgTimeDisplay = /** @class */ (function () {
        function VgTimeDisplay(ref, API) {
            this.API = API;
            this.vgProperty = 'current';
            this.vgFormat = 'mm:ss';
            this.subscriptions = [];
            this.elem = ref.nativeElement;
        }
        VgTimeDisplay.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgTimeDisplay.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
        };
        VgTimeDisplay.prototype.getTime = function () {
            var t = 0;
            if (this.target) {
                t = Math.round(this.target.time[this.vgProperty]);
                t = isNaN(t) || this.target.isLive ? 0 : t;
            }
            return t;
        };
        VgTimeDisplay.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgTimeDisplay;
    }());
    VgTimeDisplay.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-time-display',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <span *ngIf=\"target?.isLive\">LIVE</span>\n        <span *ngIf=\"!target?.isLive\">{{ getTime() | vgUtc:vgFormat }}</span>\n        <ng-content></ng-content>\n    ",
                    styles: ["\n        vg-time-display {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 60px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n            pointer-events: none;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n        }\n    "]
                },] }
    ];
    VgTimeDisplay.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgTimeDisplay.propDecorators = {
        vgFor: [{ type: i0.Input }],
        vgProperty: [{ type: i0.Input }],
        vgFormat: [{ type: i0.Input }]
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    // tslint:disable:component-class-suffix
    var VgTrackSelector = /** @class */ (function () {
        function VgTrackSelector(ref, API) {
            this.API = API;
            this.subscriptions = [];
            this.elem = ref.nativeElement;
        }
        VgTrackSelector.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgTrackSelector.prototype.onPlayerReady = function () {
            this.target = this.API.getMediaById(this.vgFor);
            var subs = Array.from(this.API.getMasterMedia().elem.children)
                .filter(function (item) { return item.tagName === 'TRACK'; })
                .filter(function (item) { return item.kind === 'subtitles'; })
                .map(function (item) { return ({
                label: item.label,
                selected: item.default === true,
                id: item.srclang
            }); });
            this.tracks = __spread(subs, [
                {
                    id: null,
                    label: 'Off',
                    selected: subs.every(function (item) { return item.selected === false; })
                }
            ]);
            var track = this.tracks.filter(function (item) { return item.selected === true; })[0];
            this.trackSelected = track.id;
            this.ariaValue = track.label;
        };
        VgTrackSelector.prototype.selectTrack = function (trackId) {
            var _this = this;
            this.trackSelected = (trackId === 'null') ? null : trackId;
            this.ariaValue = 'No track selected';
            Array.from(this.API.getMasterMedia().elem.textTracks)
                .forEach(function (item) {
                if (item.language === trackId) {
                    _this.ariaValue = item.label;
                    item.mode = 'showing';
                }
                else {
                    item.mode = 'hidden';
                }
            });
        };
        VgTrackSelector.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgTrackSelector;
    }());
    VgTrackSelector.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-track-selector',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div class=\"container\">\n            <div class=\"track-selected\"\n                [class.vg-icon-closed_caption]=\"!trackSelected\">\n                {{ trackSelected || '' }}\n            </div>\n\n            <select class=\"trackSelector\"\n                    (change)=\"selectTrack($event.target.value)\"\n                    tabindex=\"0\"\n                    aria-label=\"track selector\"\n                    [attr.aria-valuetext]=\"ariaValue\">\n                <option\n                    *ngFor=\"let track of tracks\"\n                    [value]=\"track.id\"\n                    [selected]=\"track.selected === true\">\n                    {{ track.label }}\n                </option>\n            </select>\n        </div>\n    ",
                    styles: ["\n        vg-track-selector {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            width: 50px;\n            height: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-track-selector .container {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n\n            padding: 0;\n            margin: 5px;\n        }\n        vg-track-selector select.trackSelector {\n            width: 50px;\n            padding: 5px 8px;\n            border: none;\n            background: none;\n            -webkit-appearance: none;\n            -moz-appearance: none;\n            appearance: none;\n            color: transparent;\n            font-size: 16px;\n        }\n        vg-track-selector select.trackSelector::-ms-expand {\n            display: none;\n        }\n        vg-track-selector select.trackSelector option {\n            color: #000;\n        }\n        vg-track-selector .track-selected {\n            position: absolute;\n            width: 100%;\n            height: 50px;\n            top: -6px;\n            text-align: center;\n            text-transform: uppercase;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n            padding-top: 2px;\n            pointer-events: none;\n        }\n        vg-track-selector .vg-icon-closed_caption:before {\n            width: 100%;\n        }\n    "]
                },] }
    ];
    VgTrackSelector.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgTrackSelector.propDecorators = {
        vgFor: [{ type: i0.Input }]
    };

    // tslint:disable:no-output-on-prefix
    // tslint:disable:component-class-suffix
    // tslint:disable:no-string-literal
    var VgQualitySelector = /** @class */ (function () {
        function VgQualitySelector(ref, API) {
            this.API = API;
            this.onBitrateChange = new i0.EventEmitter();
            this.subscriptions = [];
            this.elem = ref.nativeElement;
        }
        VgQualitySelector.prototype.ngOnInit = function () {
        };
        VgQualitySelector.prototype.ngOnChanges = function (changes) {
            if (changes['bitrates'].currentValue && changes['bitrates'].currentValue.length) {
                this.bitrates.forEach(function (item) { return item.label = (item.label || Math.round(item.bitrate / 1000)).toString(); });
            }
        };
        VgQualitySelector.prototype.selectBitrate = function (index) {
            this.bitrateSelected = this.bitrates[index];
            this.onBitrateChange.emit(this.bitrates[index]);
        };
        VgQualitySelector.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgQualitySelector;
    }());
    VgQualitySelector.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-quality-selector',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "\n        <div class=\"container\">\n            <div class=\"quality-selected\"\n                 [class.vg-icon-hd]=\"!bitrateSelected\">\n                {{ bitrateSelected?.label }}\n            </div>\n\n            <select class=\"quality-selector\"\n                    (change)=\"selectBitrate($event.target.value)\"\n                    tabindex=\"0\"\n                    aria-label=\"quality selector\"\n                    [attr.aria-valuetext]=\"ariaValue\">\n                <option\n                    *ngFor=\"let bitrate of bitrates\"\n                    [value]=\"bitrate.qualityIndex.toString()\"\n                    [selected]=\"bitrate.qualityIndex === bitrateSelected?.qualityIndex\">\n                    {{ bitrate.label }}\n                </option>\n            </select>\n        </div>\n    ",
                    styles: ["\n        vg-quality-selector {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            width: 50px;\n            height: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-quality-selector .container {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n\n            padding: 0;\n            margin: 5px;\n        }\n        vg-quality-selector select.quality-selector {\n            width: 50px;\n            padding: 5px 8px;\n            border: none;\n            background: none;\n            -webkit-appearance: none;\n            -moz-appearance: none;\n            appearance: none;\n            color: transparent;\n            font-size: 16px;\n        }\n        vg-quality-selector select.quality-selector::-ms-expand {\n            display: none;\n        }\n        vg-quality-selector select.quality-selector option {\n            color: #000;\n        }\n        vg-quality-selector .quality-selected {\n            position: absolute;\n            width: 100%;\n            height: 50px;\n            top: -6px;\n            text-align: center;\n            text-transform: uppercase;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n            padding-top: 2px;\n            pointer-events: none;\n        }\n        vg-quality-selector .vg-icon-closed_caption:before {\n            width: 100%;\n        }\n    "]
                },] }
    ];
    VgQualitySelector.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgQualitySelector.propDecorators = {
        bitrates: [{ type: i0.Input }],
        onBitrateChange: [{ type: i0.Output }]
    };

    var VgControlsModule = /** @class */ (function () {
        function VgControlsModule() {
        }
        return VgControlsModule;
    }());
    VgControlsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [
                        VgControls,
                        VgFullscreen,
                        VgMute,
                        VgVolume,
                        VgPlayPause,
                        VgPlaybackButton,
                        VgScrubBar,
                        VgScrubBarBufferingTime,
                        VgScrubBarCuePoints,
                        VgScrubBarCurrentTime,
                        VgTimeDisplay,
                        VgUtcPipe,
                        VgTrackSelector,
                        VgQualitySelector
                    ],
                    exports: [
                        VgControls,
                        VgFullscreen,
                        VgMute,
                        VgVolume,
                        VgPlayPause,
                        VgPlaybackButton,
                        VgScrubBar,
                        VgScrubBarBufferingTime,
                        VgScrubBarCuePoints,
                        VgScrubBarCurrentTime,
                        VgTimeDisplay,
                        VgUtcPipe,
                        VgTrackSelector,
                        VgQualitySelector
                    ],
                    providers: [VgControlsHidden]
                },] }
    ];

    var VgEvents = /** @class */ (function () {
        function VgEvents() {
        }
        return VgEvents;
    }());
    VgEvents.VG_ABORT = 'abort';
    VgEvents.VG_CAN_PLAY = 'canplay';
    VgEvents.VG_CAN_PLAY_THROUGH = 'canplaythrough';
    VgEvents.VG_DURATION_CHANGE = 'durationchange';
    VgEvents.VG_EMPTIED = 'emptied';
    VgEvents.VG_ENCRYPTED = 'encrypted';
    VgEvents.VG_ENDED = 'ended';
    VgEvents.VG_ERROR = 'error';
    VgEvents.VG_LOADED_DATA = 'loadeddata';
    VgEvents.VG_LOADED_METADATA = 'loadedmetadata';
    VgEvents.VG_LOAD_START = 'loadstart';
    VgEvents.VG_PAUSE = 'pause';
    VgEvents.VG_PLAY = 'play';
    VgEvents.VG_PLAYING = 'playing';
    VgEvents.VG_PROGRESS = 'progress';
    VgEvents.VG_RATE_CHANGE = 'ratechange';
    VgEvents.VG_SEEK = 'seek';
    VgEvents.VG_SEEKED = 'seeked';
    VgEvents.VG_SEEKING = 'seeking';
    VgEvents.VG_STALLED = 'stalled';
    VgEvents.VG_SUSPEND = 'suspend';
    VgEvents.VG_TIME_UPDATE = 'timeupdate';
    VgEvents.VG_VOLUME_CHANGE = 'volumechange';
    VgEvents.VG_WAITING = 'waiting';
    VgEvents.VG_LOAD = 'load';
    VgEvents.VG_ENTER = 'enter';
    VgEvents.VG_EXIT = 'exit';
    VgEvents.VG_START_ADS = 'startads';
    VgEvents.VG_END_ADS = 'endads';
    VgEvents.decorators = [
        { type: i0.Injectable }
    ];

    // tslint:disable-next-line:directive-class-suffix
    var VgMedia = /** @class */ (function () {
        function VgMedia(api, ref) {
            this.api = api;
            this.ref = ref;
            this.state = VgStates.VG_PAUSED;
            this.time = { current: 0, total: 0, left: 0 };
            this.buffer = { end: 0 };
            this.canPlay = false;
            this.canPlayThrough = false;
            this.isMetadataLoaded = false;
            this.isWaiting = false;
            this.isCompleted = false;
            this.isLive = false;
            this.isBufferDetected = false;
            this.checkInterval = 200;
            this.currentPlayPos = 0;
            this.lastPlayPos = 0;
            this.playAtferSync = false;
            this.bufferDetected = new rxjs.Subject();
        }
        VgMedia.prototype.ngOnInit = function () {
            var _this = this;
            if (this.vgMedia.nodeName) {
                // It's a native element
                this.elem = this.vgMedia;
            }
            else {
                // It's an Angular Class
                this.elem = this.vgMedia.elem;
            }
            // Just in case we're creating this vgMedia dynamically register again into API
            this.api.registerMedia(this);
            this.subscriptions = {
                // Native events
                abort: rxjs.fromEvent(this.elem, VgEvents.VG_ABORT),
                canPlay: rxjs.fromEvent(this.elem, VgEvents.VG_CAN_PLAY),
                canPlayThrough: rxjs.fromEvent(this.elem, VgEvents.VG_CAN_PLAY_THROUGH),
                durationChange: rxjs.fromEvent(this.elem, VgEvents.VG_DURATION_CHANGE),
                emptied: rxjs.fromEvent(this.elem, VgEvents.VG_EMPTIED),
                encrypted: rxjs.fromEvent(this.elem, VgEvents.VG_ENCRYPTED),
                ended: rxjs.fromEvent(this.elem, VgEvents.VG_ENDED),
                error: rxjs.fromEvent(this.elem, VgEvents.VG_ERROR),
                loadedData: rxjs.fromEvent(this.elem, VgEvents.VG_LOADED_DATA),
                loadedMetadata: rxjs.fromEvent(this.elem, VgEvents.VG_LOADED_METADATA),
                loadStart: rxjs.fromEvent(this.elem, VgEvents.VG_LOAD_START),
                pause: rxjs.fromEvent(this.elem, VgEvents.VG_PAUSE),
                play: rxjs.fromEvent(this.elem, VgEvents.VG_PLAY),
                playing: rxjs.fromEvent(this.elem, VgEvents.VG_PLAYING),
                progress: rxjs.fromEvent(this.elem, VgEvents.VG_PROGRESS),
                rateChange: rxjs.fromEvent(this.elem, VgEvents.VG_RATE_CHANGE),
                seeked: rxjs.fromEvent(this.elem, VgEvents.VG_SEEKED),
                seeking: rxjs.fromEvent(this.elem, VgEvents.VG_SEEKING),
                stalled: rxjs.fromEvent(this.elem, VgEvents.VG_STALLED),
                suspend: rxjs.fromEvent(this.elem, VgEvents.VG_SUSPEND),
                timeUpdate: rxjs.fromEvent(this.elem, VgEvents.VG_TIME_UPDATE),
                volumeChange: rxjs.fromEvent(this.elem, VgEvents.VG_VOLUME_CHANGE),
                waiting: rxjs.fromEvent(this.elem, VgEvents.VG_WAITING),
                // Advertisement only events
                startAds: rxjs.fromEvent(this.elem, VgEvents.VG_START_ADS),
                endAds: rxjs.fromEvent(this.elem, VgEvents.VG_END_ADS),
                // See changes on <source> child elements to reload the video file
                mutation: new rxjs.Observable(function (observer) {
                    var domObs = new MutationObserver(function (mutations) {
                        observer.next(mutations);
                    });
                    domObs.observe(_this.elem, { childList: true, attributes: true });
                    return function () {
                        domObs.disconnect();
                    };
                }),
                // Custom buffering detection
                bufferDetected: this.bufferDetected
            };
            this.mutationObs = this.subscriptions.mutation.subscribe(this.onMutation.bind(this));
            this.canPlayObs = this.subscriptions.canPlay.subscribe(this.onCanPlay.bind(this));
            this.canPlayThroughObs = this.subscriptions.canPlayThrough.subscribe(this.onCanPlayThrough.bind(this));
            this.loadedMetadataObs = this.subscriptions.loadedMetadata.subscribe(this.onLoadMetadata.bind(this));
            this.waitingObs = this.subscriptions.waiting.subscribe(this.onWait.bind(this));
            this.progressObs = this.subscriptions.progress.subscribe(this.onProgress.bind(this));
            this.endedObs = this.subscriptions.ended.subscribe(this.onComplete.bind(this));
            this.playingObs = this.subscriptions.playing.subscribe(this.onStartPlaying.bind(this));
            this.playObs = this.subscriptions.play.subscribe(this.onPlay.bind(this));
            this.pauseObs = this.subscriptions.pause.subscribe(this.onPause.bind(this));
            this.timeUpdateObs = this.subscriptions.timeUpdate.subscribe(this.onTimeUpdate.bind(this));
            this.volumeChangeObs = this.subscriptions.volumeChange.subscribe(this.onVolumeChange.bind(this));
            this.errorObs = this.subscriptions.error.subscribe(this.onError.bind(this));
            if (this.vgMaster) {
                this.api.playerReadyEvent.subscribe(function () {
                    _this.prepareSync();
                });
            }
        };
        VgMedia.prototype.prepareSync = function () {
            var _this = this;
            var canPlayAll = [];
            for (var media in this.api.medias) {
                if (this.api.medias[media]) {
                    canPlayAll.push(this.api.medias[media].subscriptions.canPlay);
                }
            }
            this.canPlayAllSubscription = rxjs.combineLatest(canPlayAll).pipe(operators.map(function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                var checkReadyState = function (event) {
                    return event.target.readyState === 4;
                };
                var allReady = params.some(checkReadyState);
                if (allReady && !_this.syncSubscription) {
                    _this.startSync();
                    _this.syncSubscription.unsubscribe();
                }
            })).subscribe();
        };
        VgMedia.prototype.startSync = function () {
            var _this = this;
            this.syncSubscription = rxjs.timer(0, 1000).subscribe(function () {
                for (var media in _this.api.medias) {
                    if (_this.api.medias[media] !== _this) {
                        var diff = _this.api.medias[media].currentTime - _this.currentTime;
                        if (diff < -0.3 || diff > 0.3) {
                            _this.playAtferSync = (_this.state === VgStates.VG_PLAYING);
                            _this.pause();
                            _this.api.medias[media].pause();
                            _this.api.medias[media].currentTime = _this.currentTime;
                        }
                        else {
                            if (_this.playAtferSync) {
                                _this.play();
                                _this.api.medias[media].play();
                                _this.playAtferSync = false;
                            }
                        }
                    }
                }
            });
        };
        VgMedia.prototype.onMutation = function (mutations) {
            // Detect changes only for source elements or src attribute
            for (var i = 0, l = mutations.length; i < l; i++) {
                var mut = mutations[i];
                if (mut.type === 'attributes' && mut.attributeName === 'src') {
                    // Only load src file if it's not a blob (for DASH / HLS sources)
                    // tslint:disable-next-line:no-string-literal
                    if (mut.target['src'] && mut.target['src'].length > 0 && mut.target['src'].indexOf('blob:') < 0) {
                        this.loadMedia();
                        break;
                    }
                }
                else if (mut.type === 'childList' && mut.removedNodes.length && mut.removedNodes[0].nodeName.toLowerCase() === 'source') {
                    this.loadMedia();
                    break;
                }
            }
        };
        VgMedia.prototype.loadMedia = function () {
            var _this = this;
            this.vgMedia.pause();
            this.vgMedia.currentTime = 0;
            // Start buffering until we can play the media file
            this.stopBufferCheck();
            this.isBufferDetected = true;
            this.bufferDetected.next(this.isBufferDetected);
            // TODO: This is ugly, we should find something cleaner. For some reason a TimerObservable doesn't works.
            setTimeout(function () { return _this.vgMedia.load(); }, 10);
        };
        VgMedia.prototype.play = function () {
            var _this = this;
            // short-circuit if already playing
            if (this.playPromise || (this.state !== VgStates.VG_PAUSED && this.state !== VgStates.VG_ENDED)) {
                return;
            }
            this.playPromise = this.vgMedia.play();
            // browser has async play promise
            if (this.playPromise && this.playPromise.then && this.playPromise.catch) {
                this.playPromise
                    .then(function () {
                    _this.playPromise = null;
                })
                    .catch(function () {
                    _this.playPromise = null;
                    // deliberately empty for the sake of eating console noise
                });
            }
            return this.playPromise;
        };
        VgMedia.prototype.pause = function () {
            var _this = this;
            // browser has async play promise
            if (this.playPromise) {
                this.playPromise
                    .then(function () {
                    _this.vgMedia.pause();
                });
            }
            else {
                this.vgMedia.pause();
            }
        };
        Object.defineProperty(VgMedia.prototype, "id", {
            get: function () {
                // We should return undefined if vgMedia still doesn't exist
                // tslint:disable-next-line:no-unnecessary-initializer
                var result = undefined;
                if (this.vgMedia) {
                    result = this.vgMedia.id;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgMedia.prototype, "duration", {
            get: function () {
                return this.vgMedia.duration;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgMedia.prototype, "currentTime", {
            get: function () {
                return this.vgMedia.currentTime;
            },
            set: function (seconds) {
                this.vgMedia.currentTime = seconds;
                // this.elem.dispatchEvent(new CustomEvent(VgEvents.VG_SEEK));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgMedia.prototype, "volume", {
            get: function () {
                return this.vgMedia.volume;
            },
            set: function (volume) {
                this.vgMedia.volume = volume;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgMedia.prototype, "playbackRate", {
            get: function () {
                return this.vgMedia.playbackRate;
            },
            set: function (rate) {
                this.vgMedia.playbackRate = rate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgMedia.prototype, "buffered", {
            get: function () {
                return this.vgMedia.buffered;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VgMedia.prototype, "textTracks", {
            get: function () {
                return this.vgMedia.textTracks;
            },
            enumerable: false,
            configurable: true
        });
        // @ts-ignore
        VgMedia.prototype.onCanPlay = function (event) {
            this.isBufferDetected = false;
            this.bufferDetected.next(this.isBufferDetected);
            this.canPlay = true;
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onCanPlayThrough = function (event) {
            this.isBufferDetected = false;
            this.bufferDetected.next(this.isBufferDetected);
            this.canPlayThrough = true;
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onLoadMetadata = function (event) {
            this.isMetadataLoaded = true;
            this.time = {
                current: 0,
                left: 0,
                total: this.duration * 1000
            };
            this.state = VgStates.VG_PAUSED;
            // Live streaming check
            var t = Math.round(this.time.total);
            this.isLive = (t === Infinity);
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onWait = function (event) {
            this.isWaiting = true;
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onComplete = function (event) {
            this.isCompleted = true;
            this.state = VgStates.VG_ENDED;
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onStartPlaying = function (event) {
            this.state = VgStates.VG_PLAYING;
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onPlay = function (event) {
            this.state = VgStates.VG_PLAYING;
            if (this.vgMaster) {
                if (!this.syncSubscription || this.syncSubscription.closed) {
                    this.startSync();
                }
            }
            this.startBufferCheck();
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onPause = function (event) {
            this.state = VgStates.VG_PAUSED;
            if (this.vgMaster) {
                if (!this.playAtferSync) {
                    this.syncSubscription.unsubscribe();
                }
            }
            this.stopBufferCheck();
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onTimeUpdate = function (event) {
            var _a;
            var end = ((_a = this.buffered) === null || _a === void 0 ? void 0 : _a.length) - 1;
            this.time = {
                current: this.currentTime * 1000,
                total: this.time.total,
                left: (this.duration - this.currentTime) * 1000
            };
            if (end >= 0) {
                this.buffer = { end: this.buffered.end(end) * 1000 };
            }
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onProgress = function (event) {
            var end = this.buffered.length - 1;
            if (end >= 0) {
                this.buffer = { end: this.buffered.end(end) * 1000 };
            }
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onVolumeChange = function (event) {
            // TODO: Save to localstorage the current volume
            this.ref.detectChanges();
        };
        // @ts-ignore
        VgMedia.prototype.onError = function (event) {
            // TODO: Handle error messages
            this.ref.detectChanges();
        };
        // http://stackoverflow.com/a/23828241/779529
        VgMedia.prototype.bufferCheck = function () {
            var offset = 1 / this.checkInterval;
            this.currentPlayPos = this.currentTime;
            if (!this.isBufferDetected && this.currentPlayPos < (this.lastPlayPos + offset)) {
                this.isBufferDetected = true;
            }
            if (this.isBufferDetected && this.currentPlayPos > (this.lastPlayPos + offset)) {
                this.isBufferDetected = false;
            }
            // Prevent calls to bufferCheck after ngOnDestroy have been called
            if (!this.bufferDetected.closed) {
                this.bufferDetected.next(this.isBufferDetected);
            }
            this.lastPlayPos = this.currentPlayPos;
        };
        VgMedia.prototype.startBufferCheck = function () {
            var _this = this;
            this.checkBufferSubscription = rxjs.timer(0, this.checkInterval).subscribe(function () {
                _this.bufferCheck();
            });
        };
        VgMedia.prototype.stopBufferCheck = function () {
            if (this.checkBufferSubscription) {
                this.checkBufferSubscription.unsubscribe();
            }
            this.isBufferDetected = false;
            this.bufferDetected.next(this.isBufferDetected);
        };
        VgMedia.prototype.seekTime = function (value, byPercent) {
            if (byPercent === void 0) { byPercent = false; }
            var second;
            var duration = this.duration;
            if (byPercent) {
                second = value * duration / 100;
            }
            else {
                second = value;
            }
            this.currentTime = second;
        };
        VgMedia.prototype.addTextTrack = function (type, label, language, mode) {
            var newTrack = this.vgMedia.addTextTrack(type, label, language);
            if (mode) {
                newTrack.mode = mode;
            }
            return newTrack;
        };
        VgMedia.prototype.ngOnDestroy = function () {
            this.vgMedia.src = '';
            this.mutationObs.unsubscribe();
            this.canPlayObs.unsubscribe();
            this.canPlayThroughObs.unsubscribe();
            this.loadedMetadataObs.unsubscribe();
            this.waitingObs.unsubscribe();
            this.progressObs.unsubscribe();
            this.endedObs.unsubscribe();
            this.playingObs.unsubscribe();
            this.playObs.unsubscribe();
            this.pauseObs.unsubscribe();
            this.timeUpdateObs.unsubscribe();
            this.volumeChangeObs.unsubscribe();
            this.errorObs.unsubscribe();
            if (this.checkBufferSubscription) {
                this.checkBufferSubscription.unsubscribe();
            }
            if (this.syncSubscription) {
                this.syncSubscription.unsubscribe();
            }
            this.bufferDetected.complete();
            this.bufferDetected.unsubscribe();
            this.api.unregisterMedia(this);
        };
        return VgMedia;
    }());
    VgMedia.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[vgMedia]'
                },] }
    ];
    VgMedia.ctorParameters = function () { return [
        { type: VgAPI },
        { type: i0.ChangeDetectorRef }
    ]; };
    VgMedia.propDecorators = {
        vgMedia: [{ type: i0.Input }],
        vgMaster: [{ type: i0.Input }]
    };

    // tslint:disable-next-line:directive-class-suffix
    var VgCuePoints = /** @class */ (function () {
        function VgCuePoints(ref) {
            this.ref = ref;
            // tslint:disable:no-output-on-prefix
            this.onEnterCuePoint = new i0.EventEmitter();
            this.onUpdateCuePoint = new i0.EventEmitter();
            this.onExitCuePoint = new i0.EventEmitter();
            this.onCompleteCuePoint = new i0.EventEmitter();
            this.subscriptions = [];
            this.cuesSubscriptions = [];
            this.totalCues = 0;
        }
        VgCuePoints.prototype.ngOnInit = function () {
            this.onLoad$ = rxjs.fromEvent(this.ref.nativeElement, VgEvents.VG_LOAD);
            this.subscriptions.push(this.onLoad$.subscribe(this.onLoad.bind(this)));
        };
        VgCuePoints.prototype.onLoad = function (event) {
            if (event.target && event.target.track) {
                var cues = event.target.track.cues;
                this.ref.nativeElement.cues = cues;
                this.updateCuePoints(cues);
            }
            else if (event.target && event.target.textTracks && event.target.textTracks.length) {
                var cues = event.target.textTracks[0].cues;
                this.ref.nativeElement.cues = cues;
                this.updateCuePoints(cues);
            }
        };
        VgCuePoints.prototype.updateCuePoints = function (cues) {
            this.cuesSubscriptions.forEach(function (s) { return s.unsubscribe(); });
            for (var i = 0, l = cues.length; i < l; i++) {
                this.onEnter$ = rxjs.fromEvent(cues[i], VgEvents.VG_ENTER);
                this.cuesSubscriptions.push(this.onEnter$.subscribe(this.onEnter.bind(this)));
                this.onExit$ = rxjs.fromEvent(cues[i], VgEvents.VG_EXIT);
                this.cuesSubscriptions.push(this.onExit$.subscribe(this.onExit.bind(this)));
            }
        };
        VgCuePoints.prototype.onEnter = function (event) {
            this.onEnterCuePoint.emit(event.target);
        };
        VgCuePoints.prototype.onExit = function (event) {
            this.onExitCuePoint.emit(event.target);
        };
        VgCuePoints.prototype.ngDoCheck = function () {
            if (this.ref.nativeElement.track && this.ref.nativeElement.track.cues) {
                var changes = this.totalCues !== this.ref.nativeElement.track.cues.length;
                if (changes) {
                    this.totalCues = this.ref.nativeElement.track.cues.length;
                    this.ref.nativeElement.cues = this.ref.nativeElement.track.cues;
                    this.updateCuePoints(this.ref.nativeElement.track.cues);
                }
            }
        };
        VgCuePoints.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgCuePoints;
    }());
    VgCuePoints.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[vgCuePoints]'
                },] }
    ];
    VgCuePoints.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    VgCuePoints.propDecorators = {
        onEnterCuePoint: [{ type: i0.Output }],
        onUpdateCuePoint: [{ type: i0.Output }],
        onExitCuePoint: [{ type: i0.Output }],
        onCompleteCuePoint: [{ type: i0.Output }]
    };

    // tslint:disable:component-class-suffix
    // tslint:disable:no-output-on-prefix
    var VgPlayer = /** @class */ (function () {
        function VgPlayer(ref, api, fsAPI, controlsHidden) {
            this.api = api;
            this.fsAPI = fsAPI;
            this.controlsHidden = controlsHidden;
            this.isFullscreen = false;
            this.isNativeFullscreen = false;
            this.areControlsHidden = false;
            this.onPlayerReady = new i0.EventEmitter();
            this.onMediaReady = new i0.EventEmitter();
            this.subscriptions = [];
            this.elem = ref.nativeElement;
            this.api.registerElement(this.elem);
        }
        VgPlayer.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.medias.toArray().forEach(function (media) {
                _this.api.registerMedia(media);
            });
            this.fsAPI.init(this.elem, this.medias);
            this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));
            this.subscriptions.push(this.controlsHidden.isHidden.subscribe(this.onHideControls.bind(this)));
            this.api.onPlayerReady(this.fsAPI);
            this.onPlayerReady.emit(this.api);
        };
        VgPlayer.prototype.onChangeFullscreen = function (fsState) {
            if (!this.fsAPI.nativeFullscreen) {
                this.isFullscreen = fsState;
                this.zIndex = fsState ? VgUtils.getZIndex().toString() : 'auto';
            }
            else {
                this.isNativeFullscreen = fsState;
            }
        };
        VgPlayer.prototype.onHideControls = function (hidden) {
            this.areControlsHidden = hidden;
        };
        VgPlayer.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgPlayer;
    }());
    VgPlayer.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-player',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "<ng-content></ng-content>",
                    providers: [VgAPI, VgFullscreenAPI, VgControlsHidden],
                    styles: ["\n        vg-player {\n            font-family: 'videogular';\n            position: relative;\n            display: flex;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n            background-color: black;\n        }\n        vg-player.fullscreen {\n            position: fixed;\n            left: 0;\n            top: 0;\n        }\n        vg-player.native-fullscreen.controls-hidden {\n            cursor: none;\n        }\n    "]
                },] }
    ];
    VgPlayer.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI },
        { type: VgFullscreenAPI },
        { type: VgControlsHidden }
    ]; };
    VgPlayer.propDecorators = {
        isFullscreen: [{ type: i0.HostBinding, args: ['class.fullscreen',] }],
        isNativeFullscreen: [{ type: i0.HostBinding, args: ['class.native-fullscreen',] }],
        areControlsHidden: [{ type: i0.HostBinding, args: ['class.controls-hidden',] }],
        zIndex: [{ type: i0.HostBinding, args: ['style.z-index',] }],
        onPlayerReady: [{ type: i0.Output }],
        onMediaReady: [{ type: i0.Output }],
        medias: [{ type: i0.ContentChildren, args: [VgMedia,] }]
    };

    var VgMediaElement = /** @class */ (function () {
        function VgMediaElement() {
        }
        Object.defineProperty(VgMediaElement.prototype, "audioTracks", {
            get: function () { return null; },
            enumerable: false,
            configurable: true
        });
        // @ts-ignore
        VgMediaElement.prototype.addTextTrack = function (kind, label, language) {
            return null;
        };
        // @ts-ignore
        VgMediaElement.prototype.canPlayType = function (type) {
            return null;
        };
        VgMediaElement.prototype.load = function () {
        };
        VgMediaElement.prototype.msClearEffects = function () {
        };
        VgMediaElement.prototype.msGetAsCastingSource = function () {
            return null;
        };
        // @ts-ignore
        VgMediaElement.prototype.msInsertAudioEffect = function (activatableClassId, effectRequired, config) {
        };
        // @ts-ignore
        VgMediaElement.prototype.msSetMediaKeys = function (mediaKeys) {
        };
        // @ts-ignore
        VgMediaElement.prototype.msSetMediaProtectionManager = function (mediaProtectionManager) {
        };
        VgMediaElement.prototype.pause = function () {
        };
        VgMediaElement.prototype.play = function () {
            return null;
        };
        // @ts-ignore
        VgMediaElement.prototype.setMediaKeys = function (mediaKeys) {
            return null;
        };
        // @ts-ignore
        VgMediaElement.prototype.addEventListener = function (type, listener, useCapture) {
        };
        return VgMediaElement;
    }());

    var VgCoreModule = /** @class */ (function () {
        function VgCoreModule() {
        }
        return VgCoreModule;
    }());
    VgCoreModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [VgMedia, VgCuePoints, VgPlayer],
                    exports: [VgMedia, VgCuePoints, VgPlayer],
                    providers: [VgAPI, VgFullscreenAPI, VgUtils, VgControlsHidden, VgStates, VgEvents]
                },] }
    ];

    // tslint:disable-next-line:no-reference
    // tslint:disable:no-output-on-prefix
    // tslint:disable:ban-types
    // tslint:disable:component-class-suffix
    var VgImaAds = /** @class */ (function () {
        function VgImaAds(ref, API, fsAPI) {
            this.API = API;
            this.fsAPI = fsAPI;
            this.onAdStart = new i0.EventEmitter();
            this.onAdStop = new i0.EventEmitter();
            this.onSkipAd = new i0.EventEmitter();
            this.isFullscreen = false;
            this.subscriptions = [];
            this.displayState = 'none';
            this.elem = ref.nativeElement;
            this.onContentEnded = this.onContentEnded.bind(this);
        }
        VgImaAds.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgImaAds.prototype.onPlayerReady = function () {
            if (typeof google === 'undefined') {
                this.onMissingGoogleImaLoader();
                return;
            }
            this.target = this.API.getMediaById(this.vgFor);
            this.initializations();
            this.subscriptions.push(this.target.subscriptions.ended.subscribe(this.onContentEnded.bind(this)));
            this.subscriptions.push(this.target.subscriptions.play.subscribe(this.onUpdateState.bind(this)));
            this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));
            this.ima.adsLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdsManagerLoaded.bind(this), false);
            this.ima.adsLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError.bind(this), false);
            this.loadAds();
        };
        VgImaAds.prototype.initializations = function () {
            var _this = this;
            this.ima = new Ima(this.elem);
            if (this.vgSkipButton) {
                this.skipButton = document.querySelector(this.vgSkipButton);
                this.skipButton.style.display = 'none';
                this.skipButton.addEventListener('click', this.onClickSkip.bind(this));
                this.elem.insertBefore(this.skipButton, this.elem.firstChild);
            }
            window.addEventListener('resize', function () {
                var w = _this.API.videogularElement.offsetWidth;
                var h = _this.API.videogularElement.offsetHeight;
                if (_this.ima.adsManager) {
                    if (_this.isFullscreen) {
                        _this.ima.adsManager.resize(w, h, google.ima.ViewMode.FULLSCREEN);
                    }
                    else {
                        _this.ima.adsManager.resize(w, h, google.ima.ViewMode.NORMAL);
                    }
                }
            });
        };
        VgImaAds.prototype.loadAds = function () {
            var _this = this;
            if (this.vgCompanion) {
                googletag.cmd.push(function () {
                    var adUnitPath = '/' + _this.vgNetwork + '/' + _this.vgUnitPath;
                    var slot = googletag.defineSlot(adUnitPath, _this.vgCompanionSize, _this.vgCompanion);
                    if (slot) {
                        slot.addService(googletag.companionAds());
                        slot.addService(googletag.pubads());
                        googletag
                            .companionAds()
                            .setRefreshUnfilledSlots(true);
                        googletag
                            .pubads()
                            .enableVideoAds();
                        googletag.enableServices();
                    }
                });
            }
        };
        VgImaAds.prototype.onUpdateState = function (event) {
            switch (event.type) {
                case VgEvents.VG_PLAY:
                    if (!this.ima.adsLoaded) {
                        this.API.pause();
                        this.ima.adDisplayContainer.initialize();
                        this.requestAds(this.vgAdTagUrl);
                        this.ima.adsLoaded = true;
                    }
                    break;
            }
        };
        VgImaAds.prototype.requestAds = function (adTagUrl) {
            // Show only to get computed style in pixels
            this.show();
            var adsRequest = new google.ima.AdsRequest();
            var computedStyle = window.getComputedStyle(this.elem);
            adsRequest.adTagUrl = adTagUrl;
            adsRequest.linearAdSlotWidth = parseInt(computedStyle.width, 10);
            adsRequest.linearAdSlotHeight = parseInt(computedStyle.height, 10);
            adsRequest.nonLinearAdSlotWidth = parseInt(computedStyle.width, 10);
            adsRequest.nonLinearAdSlotHeight = parseInt(computedStyle.height, 10);
            this.ima.adsLoader.requestAds(adsRequest);
        };
        VgImaAds.prototype.onAdsManagerLoaded = function (evt) {
            this.show();
            this.ima.adsManager = evt.getAdsManager(this.target);
            this.processAdsManager(this.ima.adsManager);
        };
        // @ts-ignore
        VgImaAds.prototype.processAdsManager = function (adsManager) {
            var w = this.API.videogularElement.offsetWidth;
            var h = this.API.videogularElement.offsetHeight;
            // Attach the pause/resume events.
            this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, this.onContentPauseRequested.bind(this), false);
            this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, this.onContentResumeRequested.bind(this), false);
            this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, this.onSkippableStateChanged.bind(this), false);
            this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.ALL_ADS_COMPLETED, this.onAllAdsComplete.bind(this), false);
            this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.COMPLETE, this.onAdComplete.bind(this), false);
            this.ima.adsManager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError.bind(this), false);
            this.ima.adsManager.init(w, h, google.ima.ViewMode.NORMAL);
            this.ima.adsManager.start();
        };
        VgImaAds.prototype.onSkippableStateChanged = function () {
            var isSkippable = this.ima.adsManager.getAdSkippableState();
            if (isSkippable) {
                this.skipButton.style.display = 'block';
            }
            else {
                this.skipButton.style.display = 'none';
            }
        };
        VgImaAds.prototype.onClickSkip = function () {
            this.ima.adsManager.skip();
            this.onSkipAd.emit(true);
        };
        VgImaAds.prototype.onContentPauseRequested = function () {
            this.show();
            this.API.pause();
            this.onAdStop.emit(true);
        };
        VgImaAds.prototype.onContentResumeRequested = function () {
            this.API.play();
            this.onAdStart.emit(true);
            this.hide();
        };
        // @ts-ignore
        VgImaAds.prototype.onAdError = function (evt) {
            if (this.ima.adsManager) {
                this.ima.adsManager.destroy();
            }
            this.hide();
            this.API.play();
            this.onAdStop.emit(true);
        };
        VgImaAds.prototype.onAllAdsComplete = function () {
            this.hide();
            // The last ad was a post-roll
            if (this.ima.adsManager.getCuePoints().join().indexOf('-1') >= 0) {
                this.API.pause(); // it was stop() in Videogular v1
                this.onAdStop.emit(true);
            }
        };
        VgImaAds.prototype.onAdComplete = function () {
            // TODO: Update view with current ad count
            this.ima.currentAd++;
            this.onAdStop.emit(true);
        };
        VgImaAds.prototype.show = function () {
            window.dispatchEvent(new CustomEvent(VgEvents.VG_START_ADS));
            this.displayState = 'block';
        };
        VgImaAds.prototype.hide = function () {
            window.dispatchEvent(new CustomEvent(VgEvents.VG_END_ADS));
            this.displayState = 'none';
        };
        VgImaAds.prototype.onContentEnded = function () {
            this.ima.adsLoader.contentComplete();
            this.onAdStop.emit(true);
        };
        VgImaAds.prototype.onChangeFullscreen = function (fsState) {
            if (!this.fsAPI.nativeFullscreen) {
                this.isFullscreen = fsState;
            }
        };
        VgImaAds.prototype.onMissingGoogleImaLoader = function () {
            this.hide();
            this.API.play();
        };
        VgImaAds.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgImaAds;
    }());
    VgImaAds.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-ima-ads',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "<div class=\"vg-ima-ads\"></div>",
                    styles: ["\n        vg-ima-ads {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            z-index: 300;\n        }\n        vg-ima-ads .vg-ima-ads {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            pointer-events: none;\n        }\n    "]
                },] }
    ];
    VgImaAds.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI },
        { type: VgFullscreenAPI }
    ]; };
    VgImaAds.propDecorators = {
        vgFor: [{ type: i0.Input }],
        vgNetwork: [{ type: i0.Input }],
        vgUnitPath: [{ type: i0.Input }],
        vgCompanion: [{ type: i0.Input }],
        vgCompanionSize: [{ type: i0.Input }],
        vgAdTagUrl: [{ type: i0.Input }],
        vgSkipButton: [{ type: i0.Input }],
        onAdStart: [{ type: i0.Output }],
        onAdStop: [{ type: i0.Output }],
        onSkipAd: [{ type: i0.Output }],
        displayState: [{ type: i0.HostBinding, args: ['style.display',] }]
    };
    var Ima = /** @class */ (function () {
        function Ima(imaAdsElement) {
            this.adDisplayContainer = new google.ima.AdDisplayContainer(imaAdsElement);
            this.adsLoader = new google.ima.AdsLoader(this.adDisplayContainer);
            this.adsManager = null;
            this.adsLoaded = false;
            this.currentAd = 0;
        }
        return Ima;
    }());

    var VgImaAdsModule = /** @class */ (function () {
        function VgImaAdsModule() {
        }
        return VgImaAdsModule;
    }());
    VgImaAdsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [
                        VgImaAds
                    ],
                    exports: [
                        VgImaAds
                    ]
                },] }
    ];

    // tslint:disable:component-class-suffix
    var VgOverlayPlay = /** @class */ (function () {
        function VgOverlayPlay(ref, API, fsAPI, controlsHidden) {
            this.API = API;
            this.fsAPI = fsAPI;
            this.controlsHidden = controlsHidden;
            this.isNativeFullscreen = false;
            this.areControlsHidden = false;
            this.subscriptions = [];
            this.isBuffering = false;
            this.elem = ref.nativeElement;
        }
        VgOverlayPlay.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgOverlayPlay.prototype.onPlayerReady = function () {
            var _this = this;
            this.target = this.API.getMediaById(this.vgFor);
            this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));
            this.subscriptions.push(this.controlsHidden.isHidden.subscribe(this.onHideControls.bind(this)));
            this.subscriptions.push(this.target.subscriptions.bufferDetected.subscribe(function (isBuffering) { return _this.onUpdateBuffer(isBuffering); }));
        };
        VgOverlayPlay.prototype.onUpdateBuffer = function (isBuffering) {
            this.isBuffering = isBuffering;
        };
        VgOverlayPlay.prototype.onChangeFullscreen = function (fsState) {
            if (this.fsAPI.nativeFullscreen) {
                this.isNativeFullscreen = fsState;
            }
        };
        VgOverlayPlay.prototype.onHideControls = function (hidden) {
            this.areControlsHidden = hidden;
        };
        VgOverlayPlay.prototype.onClick = function () {
            var state = this.getState();
            switch (state) {
                case VgStates.VG_PLAYING:
                    this.target.pause();
                    break;
                case VgStates.VG_PAUSED:
                case VgStates.VG_ENDED:
                    this.target.play();
                    break;
            }
        };
        VgOverlayPlay.prototype.getState = function () {
            var state = VgStates.VG_PAUSED;
            if (this.target) {
                if (this.target.state instanceof Array) {
                    for (var i = 0, l = this.target.state.length; i < l; i++) {
                        if (this.target.state[i] === VgStates.VG_PLAYING) {
                            state = VgStates.VG_PLAYING;
                            break;
                        }
                    }
                }
                else {
                    state = this.target.state;
                }
            }
            return state;
        };
        VgOverlayPlay.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        return VgOverlayPlay;
    }());
    VgOverlayPlay.decorators = [
        { type: i0.Component, args: [{
                    selector: 'vg-overlay-play',
                    encapsulation: i0.ViewEncapsulation.None,
                    template: "<div class=\"vg-overlay-play\"\n                    [class.native-fullscreen]=\"isNativeFullscreen\"\n                    [class.controls-hidden]=\"areControlsHidden\">\n                   <div class=\"overlay-play-container\"\n                        [class.vg-icon-play_arrow]=\"getState() !== 'playing'\">\n                   </div>\n               </div>",
                    styles: ["\n        vg-overlay-play {\n            z-index: 200;\n        }\n        vg-overlay-play.is-buffering {\n            display: none;\n        }\n        vg-overlay-play .vg-overlay-play {\n            transition: all 0.5s;\n            cursor: pointer;\n            position: absolute;\n            display: block;\n            color: white;\n            width: 100%;\n            height: 100%;\n            font-size: 80px;\n            filter: alpha(opacity=60);\n            opacity: 0.6;\n        }\n        vg-overlay-play .vg-overlay-play.native-fullscreen.controls-hidden {\n            cursor: none;\n        }\n        vg-overlay-play .vg-overlay-play .overlay-play-container.vg-icon-play_arrow {\n            pointer-events: none;\n            width: 100%;\n            height: 100%;\n            position: absolute;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-size: 80px;\n        }\n        vg-overlay-play .vg-overlay-play:hover {\n            filter: alpha(opacity=100);\n            opacity: 1;\n        }\n        vg-overlay-play .vg-overlay-play:hover .overlay-play-container.vg-icon-play_arrow:before {\n            transform: scale(1.2);\n        }\n    "]
                },] }
    ];
    VgOverlayPlay.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI },
        { type: VgFullscreenAPI },
        { type: VgControlsHidden }
    ]; };
    VgOverlayPlay.propDecorators = {
        vgFor: [{ type: i0.Input }],
        isBuffering: [{ type: i0.HostBinding, args: ['class.is-buffering',] }],
        onClick: [{ type: i0.HostListener, args: ['click',] }]
    };

    var VgOverlayPlayModule = /** @class */ (function () {
        function VgOverlayPlayModule() {
        }
        return VgOverlayPlayModule;
    }());
    VgOverlayPlayModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [
                        VgOverlayPlay
                    ],
                    exports: [
                        VgOverlayPlay
                    ]
                },] }
    ];

    // tslint:disable:directive-class-suffix
    // tslint:disable:no-output-on-prefix
    // tslint:disable:no-string-literal
    var VgDASH = /** @class */ (function () {
        function VgDASH(ref, API) {
            this.ref = ref;
            this.API = API;
            this.onGetBitrates = new i0.EventEmitter();
            this.subscriptions = [];
        }
        VgDASH.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgDASH.prototype.onPlayerReady = function () {
            this.vgFor = this.ref.nativeElement.getAttribute('vgFor');
            this.target = this.API.getMediaById(this.vgFor);
            this.createPlayer();
        };
        VgDASH.prototype.ngOnChanges = function (changes) {
            if (changes['vgDash'] && changes['vgDash'].currentValue) {
                this.createPlayer();
            }
            else {
                this.destroyPlayer();
            }
        };
        VgDASH.prototype.createPlayer = function () {
            var _this = this;
            if (this.dash) {
                this.destroyPlayer();
            }
            // It's a DASH source
            if (this.vgDash && ((this.vgDash.indexOf('.mpd') > -1) ||
                (this.vgDash.indexOf('mpd-time-csf') > -1))) {
                var drmOptions = void 0;
                if (this.vgDRMLicenseServer) {
                    drmOptions = this.vgDRMLicenseServer;
                    if (this.vgDRMToken) {
                        for (var drmServer in drmOptions) {
                            if (drmServer.hasOwnProperty(drmServer)) {
                                drmOptions[drmServer].httpRequestHeaders = { Authorization: this.vgDRMToken };
                            }
                        }
                    }
                }
                this.dash = dashjs.MediaPlayer().create();
                this.dash.getDebug().setLogToBrowserConsole(false);
                this.dash.initialize(this.ref.nativeElement);
                this.dash.setAutoPlay(false);
                this.dash.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, function () {
                    var audioList = _this.dash.getBitrateInfoListFor('audio');
                    var videoList = _this.dash.getBitrateInfoListFor('video');
                    if (audioList.length > 1) {
                        audioList.forEach(function (item) { return item.qualityIndex = ++item.qualityIndex; });
                        audioList.unshift({
                            qualityIndex: 0,
                            width: 0,
                            height: 0,
                            bitrate: 0,
                            mediaType: 'video',
                            label: 'AUTO'
                        });
                        _this.onGetBitrates.emit(audioList);
                    }
                    if (videoList.length > 1) {
                        videoList.forEach(function (item) { return item.qualityIndex = ++item.qualityIndex; });
                        videoList.unshift({
                            qualityIndex: 0,
                            width: 0,
                            height: 0,
                            bitrate: 0,
                            mediaType: 'video',
                            label: 'AUTO'
                        });
                        _this.onGetBitrates.emit(videoList);
                    }
                });
                if (drmOptions) {
                    this.dash.setProtectionData(drmOptions);
                }
                this.dash.attachSource(this.vgDash);
            }
            else {
                if (this.target) {
                    this.target.pause();
                    this.target.seekTime(0);
                    this.ref.nativeElement.src = this.vgDash;
                }
            }
        };
        VgDASH.prototype.setBitrate = function (bitrate) {
            if (this.dash) {
                if (bitrate.qualityIndex > 0) {
                    if (this.dash.getAutoSwitchQualityFor(bitrate.mediaType)) {
                        this.dash.setAutoSwitchQualityFor(bitrate.mediaType, false);
                    }
                    var nextIndex = bitrate.qualityIndex - 1;
                    this.dash.setQualityFor(bitrate.mediaType, nextIndex);
                }
                else {
                    this.dash.setAutoSwitchQualityFor(bitrate.mediaType, true);
                }
            }
        };
        VgDASH.prototype.destroyPlayer = function () {
            if (this.dash) {
                this.dash.reset();
                this.dash = null;
            }
        };
        VgDASH.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
            this.destroyPlayer();
        };
        return VgDASH;
    }());
    VgDASH.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[vgDash]',
                    exportAs: 'vgDash'
                },] }
    ];
    VgDASH.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgDASH.propDecorators = {
        vgDash: [{ type: i0.Input }],
        vgDRMToken: [{ type: i0.Input }],
        vgDRMLicenseServer: [{ type: i0.Input }],
        onGetBitrates: [{ type: i0.Output }]
    };

    // tslint:disable:no-string-literal
    // tslint:disable:directive-class-suffix
    // tslint:disable:no-output-on-prefix
    var VgHLS = /** @class */ (function () {
        function VgHLS(ref, API) {
            this.ref = ref;
            this.API = API;
            this.vgHlsHeaders = {};
            this.onGetBitrates = new i0.EventEmitter();
            this.subscriptions = [];
        }
        VgHLS.prototype.ngOnInit = function () {
            var _this = this;
            if (this.API.isPlayerReady) {
                this.onPlayerReady();
            }
            else {
                this.subscriptions.push(this.API.playerReadyEvent.subscribe(function () { return _this.onPlayerReady(); }));
            }
        };
        VgHLS.prototype.onPlayerReady = function () {
            var _this = this;
            this.crossorigin = this.ref.nativeElement.getAttribute('crossorigin');
            this.preload = this.ref.nativeElement.getAttribute('preload') !== 'none';
            this.vgFor = this.ref.nativeElement.getAttribute('vgFor');
            if (this.vgFor) {
                this.target = this.API.getMediaById(this.vgFor);
            }
            else {
                this.target = this.API.getDefaultMedia();
            }
            this.config = {
                autoStartLoad: this.preload
            };
            // @ts-ignore
            this.config.xhrSetup = function (xhr, url) {
                var e_1, _a;
                // Send cookies
                if (_this.crossorigin === 'use-credentials') {
                    xhr.withCredentials = true;
                }
                try {
                    for (var _b = __values(Object.keys(_this.vgHlsHeaders)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var key = _c.value;
                        xhr.setRequestHeader(key, _this.vgHlsHeaders[key]);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            };
            this.createPlayer();
            if (!this.preload) {
                this.subscriptions.push(this.API.subscriptions.play.subscribe(function () {
                    if (_this.hls) {
                        _this.hls.startLoad(0);
                    }
                }));
            }
        };
        VgHLS.prototype.ngOnChanges = function (changes) {
            if (changes['vgHls'] && changes['vgHls'].currentValue) {
                this.createPlayer();
            }
            else if (changes['vgHlsHeaders'] && changes['vgHlsHeaders'].currentValue) {
                // Do nothing. We don't want to create a or destroy a player if the headers change.
            }
            else {
                this.destroyPlayer();
            }
        };
        VgHLS.prototype.createPlayer = function () {
            var _this = this;
            if (this.hls) {
                this.destroyPlayer();
            }
            // It's a HLS source
            if (this.vgHls && this.vgHls.indexOf('m3u8') > -1 && Hls.isSupported() && this.API.isPlayerReady) {
                var video = this.ref.nativeElement;
                this.hls = new Hls(this.config);
                // @ts-ignore
                this.hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
                    var videoList = [];
                    videoList.push({
                        qualityIndex: 0,
                        width: 0,
                        height: 0,
                        bitrate: 0,
                        mediaType: 'video',
                        label: 'AUTO'
                    });
                    data.levels.forEach(function (item, index) {
                        videoList.push({
                            qualityIndex: ++index,
                            width: item.width,
                            height: item.height,
                            bitrate: item.bitrate,
                            mediaType: 'video',
                            label: item.name
                        });
                    });
                    _this.onGetBitrates.emit(videoList);
                });
                // @ts-ignore
                this.hls.on(Hls.Events.LEVEL_LOADED, function (event, data) {
                    _this.target.isLive = data.details.live;
                });
                this.hls.loadSource(this.vgHls);
                this.hls.attachMedia(video);
            }
            else {
                if (this.target && !!this.target.pause) {
                    this.target.pause();
                    this.target.seekTime(0);
                    this.ref.nativeElement.src = this.vgHls;
                }
            }
        };
        VgHLS.prototype.setBitrate = function (bitrate) {
            if (this.hls) {
                this.hls.nextLevel = bitrate.qualityIndex - 1;
            }
        };
        VgHLS.prototype.destroyPlayer = function () {
            if (this.hls) {
                this.hls.destroy();
                this.hls = null;
            }
        };
        VgHLS.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
            this.destroyPlayer();
            delete this.hls;
        };
        return VgHLS;
    }());
    VgHLS.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[vgHls]',
                    exportAs: 'vgHls'
                },] }
    ];
    VgHLS.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: VgAPI }
    ]; };
    VgHLS.propDecorators = {
        vgHls: [{ type: i0.Input }],
        vgHlsHeaders: [{ type: i0.Input }],
        onGetBitrates: [{ type: i0.Output }]
    };

    var VgStreamingModule = /** @class */ (function () {
        function VgStreamingModule() {
        }
        return VgStreamingModule;
    }());
    VgStreamingModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [
                        VgDASH, VgHLS
                    ],
                    exports: [
                        VgDASH, VgHLS
                    ]
                },] }
    ];

    /*
     * Public API Surface of ngx-videogular
     */
    // Required for Ivy Build of Library
    // export * from './lib/buffering/vg-buffering';
    // export * from './lib/controls/vg-controls';
    // export * from './lib/controls/vg-fullscreen/vg-fullscreen';
    // export * from './lib/controls/vg-mute/vg-mute';
    // export * from './lib/controls/vg-play-pause/vg-play-pause';
    // export * from './lib/controls/vg-playback-button/vg-playback-button';
    // export * from './lib/controls/vg-volume/vg-volume';
    // export * from './lib/controls/vg-quality-selector/vg-quality-selector';
    // export * from './lib/controls/vg-scrub-bar/vg-scrub-bar';
    // export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-buffering-time/vg-scrub-bar-buffering-time';
    // export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-cue-points/vg-scrub-bar-cue-points';
    // export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-current-time/vg-scrub-bar-current-time';
    // export * from './lib/controls/vg-time-display/vg-time-display';
    // export * from './lib/controls/vg-track-selector/vg-track-selector';
    // export * from './lib/core/vg-player/vg-player';
    // export * from './lib/core/vg-media/vg-media';
    // export * from './lib/core/vg-cue-points/vg-cue-points';
    // export * from './lib/ima-ads/vg-ima-ads';
    // export * from './lib/overlay-play/vg-overlay-play';

    /**
     * Generated bundle index. Do not edit.
     */

    exports.VgAPI = VgAPI;
    exports.VgBufferingModule = VgBufferingModule;
    exports.VgControlsHidden = VgControlsHidden;
    exports.VgControlsModule = VgControlsModule;
    exports.VgCoreModule = VgCoreModule;
    exports.VgDASH = VgDASH;
    exports.VgEvents = VgEvents;
    exports.VgFullscreenAPI = VgFullscreenAPI;
    exports.VgHLS = VgHLS;
    exports.VgImaAdsModule = VgImaAdsModule;
    exports.VgMediaElement = VgMediaElement;
    exports.VgOverlayPlayModule = VgOverlayPlayModule;
    exports.VgStates = VgStates;
    exports.VgStreamingModule = VgStreamingModule;
    exports.VgUtils = VgUtils;
    exports.ɵa = VgBuffering;
    exports.ɵb = VgControls;
    exports.ɵc = VgFullscreen;
    exports.ɵd = VgMute;
    exports.ɵe = VgVolume;
    exports.ɵf = VgPlayPause;
    exports.ɵg = VgPlaybackButton;
    exports.ɵh = VgScrubBar;
    exports.ɵi = VgScrubBarBufferingTime;
    exports.ɵj = VgScrubBarCuePoints;
    exports.ɵk = VgScrubBarCurrentTime;
    exports.ɵl = VgUtcPipe;
    exports.ɵm = VgTimeDisplay;
    exports.ɵn = VgTrackSelector;
    exports.ɵo = VgQualitySelector;
    exports.ɵp = VgMedia;
    exports.ɵq = VgCuePoints;
    exports.ɵr = VgPlayer;
    exports.ɵs = VgImaAds;
    exports.ɵt = VgOverlayPlay;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-videogular.umd.js.map
