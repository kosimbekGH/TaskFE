{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, ElementRef, Output, ChangeDetectorRef, Input, Component, ViewEncapsulation, HostBinding, ContentChildren, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Subject, fromEvent, Observable, combineLatest, timer } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"*\"];\nlet VgStates = /*#__PURE__*/(() => {\n  class VgStates {}\n\n  VgStates.ɵfac = function VgStates_Factory(t) {\n    return new (t || VgStates)();\n  };\n\n  VgStates.VG_ENDED = 'ended';\n  VgStates.VG_PAUSED = 'paused';\n  VgStates.VG_PLAYING = 'playing';\n  VgStates.VG_LOADING = 'waiting';\n  /** @nocollapse */\n\n  VgStates.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function VgStates_Factory() {\n      return new VgStates();\n    },\n    token: VgStates,\n    providedIn: \"root\"\n  });\n  return VgStates;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgApiService = /*#__PURE__*/(() => {\n  class VgApiService {\n    constructor() {\n      this.medias = {}; // TODO: refactor to Set<IPlayable>\n\n      this.playerReadyEvent = new EventEmitter(true);\n      this.isPlayerReady = false;\n    }\n\n    onPlayerReady(fsAPI) {\n      this.fsAPI = fsAPI;\n      this.isPlayerReady = true;\n      this.playerReadyEvent.emit(this);\n    }\n\n    getDefaultMedia() {\n      for (const item in this.medias) {\n        if (this.medias[item]) {\n          return this.medias[item];\n        }\n      }\n    }\n\n    getMasterMedia() {\n      let master;\n\n      for (const id in this.medias) {\n        if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {\n          master = this.medias[id];\n          break;\n        }\n      }\n\n      return master || this.getDefaultMedia();\n    }\n\n    isMasterDefined() {\n      let result = false;\n\n      for (const id in this.medias) {\n        if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {\n          result = true;\n          break;\n        }\n      }\n\n      return result;\n    }\n\n    getMediaById(id = null) {\n      let media = this.medias[id];\n\n      if (!id || id === '*') {\n        media = this;\n      }\n\n      return media;\n    }\n\n    play() {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.medias[id].play();\n        }\n      }\n    }\n\n    pause() {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.medias[id].pause();\n        }\n      }\n    }\n\n    get duration() {\n      return this.$$getAllProperties('duration');\n    }\n\n    set currentTime(seconds) {\n      this.$$setAllProperties('currentTime', seconds);\n    }\n\n    get currentTime() {\n      return this.$$getAllProperties('currentTime');\n    }\n\n    set state(state) {\n      this.$$setAllProperties('state', state);\n    }\n\n    get state() {\n      return this.$$getAllProperties('state');\n    }\n\n    set volume(volume) {\n      this.$$setAllProperties('volume', volume);\n    }\n\n    get volume() {\n      return this.$$getAllProperties('volume');\n    }\n\n    set playbackRate(rate) {\n      this.$$setAllProperties('playbackRate', rate);\n    }\n\n    get playbackRate() {\n      return this.$$getAllProperties('playbackRate');\n    }\n\n    get canPlay() {\n      return this.$$getAllProperties('canPlay');\n    }\n\n    get canPlayThrough() {\n      return this.$$getAllProperties('canPlayThrough');\n    }\n\n    get isMetadataLoaded() {\n      return this.$$getAllProperties('isMetadataLoaded');\n    }\n\n    get isWaiting() {\n      return this.$$getAllProperties('isWaiting');\n    }\n\n    get isCompleted() {\n      return this.$$getAllProperties('isCompleted');\n    }\n\n    get isLive() {\n      return this.$$getAllProperties('isLive');\n    }\n\n    get isMaster() {\n      return this.$$getAllProperties('isMaster');\n    }\n\n    get time() {\n      return this.$$getAllProperties('time');\n    }\n\n    get buffer() {\n      return this.$$getAllProperties('buffer');\n    }\n\n    get buffered() {\n      return this.$$getAllProperties('buffered');\n    }\n\n    get subscriptions() {\n      return this.$$getAllProperties('subscriptions');\n    }\n\n    get textTracks() {\n      return this.$$getAllProperties('textTracks');\n    }\n\n    seekTime(value, byPercent = false) {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.$$seek(this.medias[id], value, byPercent);\n        }\n      }\n    }\n\n    $$seek(media, value, byPercent = false) {\n      let second;\n      let duration = media.duration;\n\n      if (byPercent) {\n        if (this.isMasterDefined()) {\n          duration = this.getMasterMedia().duration;\n        }\n\n        second = value * duration / 100;\n      } else {\n        second = value;\n      }\n\n      media.currentTime = second;\n    }\n\n    addTextTrack(type, label, language) {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.$$addTextTrack(this.medias[id], type, label, language);\n        }\n      }\n    }\n\n    $$addTextTrack(media, type, label, language) {\n      media.addTextTrack(type, label, language);\n    }\n\n    $$getAllProperties(property) {\n      const medias = {};\n      let result;\n\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          medias[id] = this.medias[id];\n        }\n      }\n\n      const nMedias = Object.keys(medias).length;\n\n      switch (nMedias) {\n        case 0:\n          // Return default values until vgMedia is initialized\n          switch (property) {\n            case 'state':\n              result = VgStates.VG_PAUSED;\n              break;\n\n            case 'playbackRate':\n            case 'volume':\n              result = 1;\n              break;\n\n            case 'time':\n              result = {\n                current: 0,\n                total: 0,\n                left: 0\n              };\n              break;\n          }\n\n          break;\n\n        case 1:\n          // If there's only one media element then return the plain value\n          const firstMediaId = Object.keys(medias)[0];\n          result = medias[firstMediaId][property];\n          break;\n\n        default:\n          // TODO: return 'master' value\n          const master = this.getMasterMedia();\n          result = medias[master.id][property];\n      }\n\n      return result;\n    }\n\n    $$setAllProperties(property, value) {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.medias[id][property] = value;\n        }\n      }\n    }\n\n    registerElement(elem) {\n      this.videogularElement = elem;\n    }\n\n    registerMedia(media) {\n      this.medias[media.id] = media;\n    }\n\n    unregisterMedia(media) {\n      delete this.medias[media.id];\n    }\n\n  }\n\n  VgApiService.ɵfac = function VgApiService_Factory(t) {\n    return new (t || VgApiService)();\n  };\n  /** @nocollapse */\n\n\n  VgApiService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function VgApiService_Factory() {\n      return new VgApiService();\n    },\n    token: VgApiService,\n    providedIn: \"root\"\n  });\n  /** @nocollapse */\n\n  return VgApiService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgControlsHiddenService = /*#__PURE__*/(() => {\n  class VgControlsHiddenService {\n    constructor() {\n      this.isHiddenSubject = new Subject();\n      this.isHidden = this.isHiddenSubject.asObservable();\n    }\n\n    state(hidden) {\n      this.isHiddenSubject.next(hidden);\n    }\n\n  }\n\n  VgControlsHiddenService.ɵfac = function VgControlsHiddenService_Factory(t) {\n    return new (t || VgControlsHiddenService)();\n  };\n  /** @nocollapse */\n\n\n  VgControlsHiddenService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function VgControlsHiddenService_Factory() {\n      return new VgControlsHiddenService();\n    },\n    token: VgControlsHiddenService,\n    providedIn: \"root\"\n  });\n  /** @nocollapse */\n\n  return VgControlsHiddenService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgUtilsService = /*#__PURE__*/(() => {\n  class VgUtilsService {\n    /**\n     * Inspired by Paul Irish\n     * https://gist.github.com/paulirish/211209\n     */\n    static getZIndex() {\n      let zIndex = 1;\n      let elementZIndex;\n      const tags = document.getElementsByTagName('*');\n\n      for (let i = 0, l = tags.length; i < l; i++) {\n        elementZIndex = parseInt(window.getComputedStyle(tags[i])['z-index'], 10);\n\n        if (elementZIndex > zIndex) {\n          zIndex = elementZIndex + 1;\n        }\n      }\n\n      return zIndex;\n    } // Very simple mobile detection, not 100% reliable\n\n\n    static isMobileDevice() {\n      // return (\n      //   typeof window.screen.orientation !== 'undefined' ||\n      //   navigator.userAgent.indexOf('IEMobile') !== -1\n      // );\n      // window.orientation is deprecated and we should use window.screen.orientation\n      return typeof window.orientation !== 'undefined' || navigator.userAgent.indexOf('IEMobile') !== -1;\n    }\n\n    static isiOSDevice() {\n      return (navigator.userAgent.match(/ip(hone|ad|od)/i) || VgUtilsService.isIpadOS()) && !navigator.userAgent.match(/(iemobile)[\\/\\s]?([\\w\\.]*)/i);\n    }\n\n    static isIpadOS() {\n      return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);\n    }\n\n    static isCordova() {\n      return document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;\n    }\n\n  }\n\n  VgUtilsService.ɵfac = function VgUtilsService_Factory(t) {\n    return new (t || VgUtilsService)();\n  };\n  /** @nocollapse */\n\n\n  VgUtilsService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function VgUtilsService_Factory() {\n      return new VgUtilsService();\n    },\n    token: VgUtilsService,\n    providedIn: \"root\"\n  });\n  return VgUtilsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgFullscreenApiService = /*#__PURE__*/(() => {\n  class VgFullscreenApiService {\n    constructor() {\n      this.nativeFullscreen = true;\n      this.isFullscreen = false;\n      this.onChangeFullscreen = new EventEmitter();\n    }\n\n    init(elem, medias) {\n      this.videogularElement = elem;\n      this.medias = medias;\n      const APIs = {\n        w3: {\n          enabled: 'fullscreenEnabled',\n          element: 'fullscreenElement',\n          request: 'requestFullscreen',\n          exit: 'exitFullscreen',\n          onchange: 'fullscreenchange',\n          onerror: 'fullscreenerror'\n        },\n        newWebkit: {\n          enabled: 'webkitFullscreenEnabled',\n          element: 'webkitFullscreenElement',\n          request: 'webkitRequestFullscreen',\n          exit: 'webkitExitFullscreen',\n          onchange: 'webkitfullscreenchange',\n          onerror: 'webkitfullscreenerror'\n        },\n        oldWebkit: {\n          enabled: 'webkitIsFullScreen',\n          element: 'webkitCurrentFullScreenElement',\n          request: 'webkitRequestFullScreen',\n          exit: 'webkitCancelFullScreen',\n          onchange: 'webkitfullscreenchange',\n          onerror: 'webkitfullscreenerror'\n        },\n        moz: {\n          enabled: 'mozFullScreen',\n          element: 'mozFullScreenElement',\n          request: 'mozRequestFullScreen',\n          exit: 'mozCancelFullScreen',\n          onchange: 'mozfullscreenchange',\n          onerror: 'mozfullscreenerror'\n        },\n        ios: {\n          enabled: 'webkitFullscreenEnabled',\n          element: 'webkitFullscreenElement',\n          request: 'webkitEnterFullscreen',\n          exit: 'webkitExitFullscreen',\n          onchange: 'webkitendfullscreen',\n          onerror: 'webkitfullscreenerror'\n        },\n        ms: {\n          enabled: 'msFullscreenEnabled',\n          element: 'msFullscreenElement',\n          request: 'msRequestFullscreen',\n          exit: 'msExitFullscreen',\n          onchange: 'MSFullscreenChange',\n          onerror: 'MSFullscreenError'\n        }\n      };\n\n      for (const browser in APIs) {\n        if (APIs[browser].enabled in document) {\n          this.polyfill = APIs[browser];\n          break;\n        }\n      }\n\n      if (VgUtilsService.isiOSDevice()) {\n        this.polyfill = APIs.ios;\n      }\n\n      this.isAvailable = this.polyfill != null;\n\n      if (this.polyfill == null) {\n        return;\n      }\n\n      let fsElemDispatcher;\n\n      switch (this.polyfill.onchange) {\n        // Mozilla dispatches the fullscreen change event from document, not the element\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=724816#c3\n        case 'mozfullscreenchange':\n          fsElemDispatcher = document;\n          break;\n        // iOS dispatches the fullscreen change event from video element\n\n        case 'webkitendfullscreen':\n          fsElemDispatcher = this.medias.toArray()[0].elem;\n          break;\n        // HTML5 implementation dispatches the fullscreen change event from the element\n\n        default:\n          fsElemDispatcher = elem;\n      }\n\n      this.fsChangeSubscription = fromEvent(fsElemDispatcher, this.polyfill.onchange).subscribe(() => {\n        this.onFullscreenChange();\n      });\n    }\n\n    onFullscreenChange() {\n      this.isFullscreen = !!document[this.polyfill.element];\n      this.onChangeFullscreen.emit(this.isFullscreen);\n    }\n\n    toggleFullscreen(element = null) {\n      if (this.isFullscreen) {\n        this.exit();\n      } else {\n        this.request(element);\n      }\n    }\n\n    request(elem) {\n      if (!elem) {\n        elem = this.videogularElement;\n      }\n\n      this.isFullscreen = true;\n      this.onChangeFullscreen.emit(true); // Perform native full screen support\n\n      if (this.isAvailable && this.nativeFullscreen) {\n        // Fullscreen for mobile devices\n        if (VgUtilsService.isMobileDevice()) {\n          // We should make fullscreen the video object if it doesn't have native fullscreen support\n          // Fallback! We can't set vg-player on fullscreen, only video/audio objects\n          if (!this.polyfill.enabled && elem === this.videogularElement || VgUtilsService.isiOSDevice()) {\n            elem = this.medias.toArray()[0].elem;\n          }\n\n          this.enterElementInFullScreen(elem);\n        } else {\n          this.enterElementInFullScreen(this.videogularElement);\n        }\n      }\n    }\n\n    enterElementInFullScreen(elem) {\n      elem[this.polyfill.request]();\n    }\n\n    exit() {\n      this.isFullscreen = false;\n      this.onChangeFullscreen.emit(false); // Exit from native fullscreen\n\n      if (this.isAvailable && this.nativeFullscreen) {\n        document[this.polyfill.exit]();\n      }\n    }\n\n  }\n\n  VgFullscreenApiService.ɵfac = function VgFullscreenApiService_Factory(t) {\n    return new (t || VgFullscreenApiService)();\n  };\n  /** @nocollapse */\n\n\n  VgFullscreenApiService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function VgFullscreenApiService_Factory() {\n      return new VgFullscreenApiService();\n    },\n    token: VgFullscreenApiService,\n    providedIn: \"root\"\n  });\n  /** @nocollapse */\n\n  return VgFullscreenApiService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgEvents = /*#__PURE__*/(() => {\n  class VgEvents {}\n\n  VgEvents.ɵfac = function VgEvents_Factory(t) {\n    return new (t || VgEvents)();\n  };\n\n  VgEvents.VG_ABORT = 'abort';\n  VgEvents.VG_CAN_PLAY = 'canplay';\n  VgEvents.VG_CAN_PLAY_THROUGH = 'canplaythrough';\n  VgEvents.VG_DURATION_CHANGE = 'durationchange';\n  VgEvents.VG_EMPTIED = 'emptied';\n  VgEvents.VG_ENCRYPTED = 'encrypted';\n  VgEvents.VG_ENDED = 'ended';\n  VgEvents.VG_ERROR = 'error';\n  VgEvents.VG_LOADED_DATA = 'loadeddata';\n  VgEvents.VG_LOADED_METADATA = 'loadedmetadata';\n  VgEvents.VG_LOAD_START = 'loadstart';\n  VgEvents.VG_PAUSE = 'pause';\n  VgEvents.VG_PLAY = 'play';\n  VgEvents.VG_PLAYING = 'playing';\n  VgEvents.VG_PROGRESS = 'progress';\n  VgEvents.VG_RATE_CHANGE = 'ratechange';\n  VgEvents.VG_SEEK = 'seek';\n  VgEvents.VG_SEEKED = 'seeked';\n  VgEvents.VG_SEEKING = 'seeking';\n  VgEvents.VG_STALLED = 'stalled';\n  VgEvents.VG_SUSPEND = 'suspend';\n  VgEvents.VG_TIME_UPDATE = 'timeupdate';\n  VgEvents.VG_VOLUME_CHANGE = 'volumechange';\n  VgEvents.VG_WAITING = 'waiting';\n  VgEvents.VG_LOAD = 'load';\n  VgEvents.VG_ENTER = 'enter';\n  VgEvents.VG_EXIT = 'exit';\n  VgEvents.VG_START_ADS = 'startads';\n  VgEvents.VG_END_ADS = 'endads';\n  /** @nocollapse */\n\n  VgEvents.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function VgEvents_Factory() {\n      return new VgEvents();\n    },\n    token: VgEvents,\n    providedIn: \"root\"\n  });\n  return VgEvents;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgCuePointsDirective = /*#__PURE__*/(() => {\n  class VgCuePointsDirective {\n    constructor(ref) {\n      this.ref = ref;\n      this.onEnterCuePoint = new EventEmitter();\n      this.onUpdateCuePoint = new EventEmitter();\n      this.onExitCuePoint = new EventEmitter();\n      this.onCompleteCuePoint = new EventEmitter();\n      this.subscriptions = [];\n      this.cuesSubscriptions = [];\n      this.totalCues = 0;\n    }\n\n    ngOnInit() {\n      this.onLoad$ = fromEvent(this.ref.nativeElement, VgEvents.VG_LOAD);\n      this.subscriptions.push(this.onLoad$.subscribe(this.onLoad.bind(this)));\n    }\n\n    onLoad(event) {\n      const cues = event.target.track.cues;\n      this.ref.nativeElement.cues = cues;\n      this.updateCuePoints(cues);\n    }\n\n    updateCuePoints(cues) {\n      this.cuesSubscriptions.forEach(s => s.unsubscribe());\n\n      for (let i = 0, l = cues.length; i < l; i++) {\n        this.onEnter$ = fromEvent(cues[i], VgEvents.VG_ENTER);\n        this.cuesSubscriptions.push(this.onEnter$.subscribe(this.onEnter.bind(this)));\n        this.onExit$ = fromEvent(cues[i], VgEvents.VG_EXIT);\n        this.cuesSubscriptions.push(this.onExit$.subscribe(this.onExit.bind(this)));\n      }\n    }\n\n    onEnter(event) {\n      this.onEnterCuePoint.emit(event.target);\n    }\n\n    onExit(event) {\n      this.onExitCuePoint.emit(event.target);\n    }\n\n    ngDoCheck() {\n      if (this.ref.nativeElement.track && this.ref.nativeElement.track.cues) {\n        const changes = this.totalCues !== this.ref.nativeElement.track.cues.length;\n\n        if (changes) {\n          this.totalCues = this.ref.nativeElement.track.cues.length;\n          this.ref.nativeElement.cues = this.ref.nativeElement.track.cues;\n          this.updateCuePoints(this.ref.nativeElement.track.cues);\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgCuePointsDirective.ɵfac = function VgCuePointsDirective_Factory(t) {\n    return new (t || VgCuePointsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  VgCuePointsDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: VgCuePointsDirective,\n    selectors: [[\"\", \"vgCuePoints\", \"\"]],\n    outputs: {\n      onEnterCuePoint: \"onEnterCuePoint\",\n      onUpdateCuePoint: \"onUpdateCuePoint\",\n      onExitCuePoint: \"onExitCuePoint\",\n      onCompleteCuePoint: \"onCompleteCuePoint\"\n    }\n  });\n  /** @nocollapse */\n\n  return VgCuePointsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgMediaDirective = /*#__PURE__*/(() => {\n  class VgMediaDirective {\n    constructor(api, ref) {\n      this.api = api;\n      this.ref = ref;\n      this.state = VgStates.VG_PAUSED;\n      this.time = {\n        current: 0,\n        total: 0,\n        left: 0\n      };\n      this.buffer = {\n        end: 0\n      };\n      this.canPlay = false;\n      this.canPlayThrough = false;\n      this.isMetadataLoaded = false;\n      this.isWaiting = false;\n      this.isCompleted = false;\n      this.isLive = false;\n      this.isBufferDetected = false;\n      this.checkInterval = 200;\n      this.currentPlayPos = 0;\n      this.lastPlayPos = 0;\n      this.playAtferSync = false;\n      this.bufferDetected = new Subject();\n    }\n\n    ngOnInit() {\n      if (this.vgMedia.nodeName) {\n        // It's a native element\n        this.elem = this.vgMedia;\n      } else {\n        // It's an Angular Class\n        this.elem = this.vgMedia.elem;\n      } // Just in case we're creating this vgMedia dynamically register again into API\n\n\n      this.api.registerMedia(this);\n      this.subscriptions = {\n        // Native events\n        abort: fromEvent(this.elem, VgEvents.VG_ABORT),\n        canPlay: fromEvent(this.elem, VgEvents.VG_CAN_PLAY),\n        canPlayThrough: fromEvent(this.elem, VgEvents.VG_CAN_PLAY_THROUGH),\n        durationChange: fromEvent(this.elem, VgEvents.VG_DURATION_CHANGE),\n        emptied: fromEvent(this.elem, VgEvents.VG_EMPTIED),\n        encrypted: fromEvent(this.elem, VgEvents.VG_ENCRYPTED),\n        ended: fromEvent(this.elem, VgEvents.VG_ENDED),\n        error: fromEvent(this.elem, VgEvents.VG_ERROR),\n        loadedData: fromEvent(this.elem, VgEvents.VG_LOADED_DATA),\n        loadedMetadata: fromEvent(this.elem, VgEvents.VG_LOADED_METADATA),\n        loadStart: fromEvent(this.elem, VgEvents.VG_LOAD_START),\n        pause: fromEvent(this.elem, VgEvents.VG_PAUSE),\n        play: fromEvent(this.elem, VgEvents.VG_PLAY),\n        playing: fromEvent(this.elem, VgEvents.VG_PLAYING),\n        progress: fromEvent(this.elem, VgEvents.VG_PROGRESS),\n        rateChange: fromEvent(this.elem, VgEvents.VG_RATE_CHANGE),\n        seeked: fromEvent(this.elem, VgEvents.VG_SEEKED),\n        seeking: fromEvent(this.elem, VgEvents.VG_SEEKING),\n        stalled: fromEvent(this.elem, VgEvents.VG_STALLED),\n        suspend: fromEvent(this.elem, VgEvents.VG_SUSPEND),\n        timeUpdate: fromEvent(this.elem, VgEvents.VG_TIME_UPDATE),\n        volumeChange: fromEvent(this.elem, VgEvents.VG_VOLUME_CHANGE),\n        waiting: fromEvent(this.elem, VgEvents.VG_WAITING),\n        // Advertisement only events\n        startAds: fromEvent(window, VgEvents.VG_START_ADS),\n        endAds: fromEvent(window, VgEvents.VG_END_ADS),\n        // See changes on <source> child elements to reload the video file\n        mutation: new Observable(observer => {\n          const domObs = new MutationObserver(mutations => {\n            observer.next(mutations);\n          });\n          domObs.observe(this.elem, {\n            childList: true,\n            attributes: true\n          });\n          return () => {\n            domObs.disconnect();\n          };\n        }),\n        // Custom buffering detection\n        bufferDetected: this.bufferDetected\n      };\n      this.mutationObs = this.subscriptions.mutation.subscribe(this.onMutation.bind(this));\n      this.canPlayObs = this.subscriptions.canPlay.subscribe(this.onCanPlay.bind(this));\n      this.canPlayThroughObs = this.subscriptions.canPlayThrough.subscribe(this.onCanPlayThrough.bind(this));\n      this.loadedMetadataObs = this.subscriptions.loadedMetadata.subscribe(this.onLoadMetadata.bind(this));\n      this.waitingObs = this.subscriptions.waiting.subscribe(this.onWait.bind(this));\n      this.progressObs = this.subscriptions.progress.subscribe(this.onProgress.bind(this));\n      this.endedObs = this.subscriptions.ended.subscribe(this.onComplete.bind(this));\n      this.playingObs = this.subscriptions.playing.subscribe(this.onStartPlaying.bind(this));\n      this.playObs = this.subscriptions.play.subscribe(this.onPlay.bind(this));\n      this.pauseObs = this.subscriptions.pause.subscribe(this.onPause.bind(this));\n      this.timeUpdateObs = this.subscriptions.timeUpdate.subscribe(this.onTimeUpdate.bind(this));\n      this.volumeChangeObs = this.subscriptions.volumeChange.subscribe(this.onVolumeChange.bind(this));\n      this.errorObs = this.subscriptions.error.subscribe(this.onError.bind(this));\n\n      if (this.vgMaster) {\n        this.api.playerReadyEvent.subscribe(() => {\n          this.prepareSync();\n        });\n      }\n    }\n\n    prepareSync() {\n      const canPlayAll = [];\n\n      for (const media in this.api.medias) {\n        if (this.api.medias[media]) {\n          canPlayAll.push(this.api.medias[media].subscriptions.canPlay);\n        }\n      }\n\n      this.canPlayAllSubscription = combineLatest(canPlayAll).pipe(map((...params) => {\n        const checkReadyState = event => {\n          if (!(event === null || event === void 0 ? void 0 : event.target)) {\n            return false;\n          }\n\n          return event.target.readyState === 4;\n        };\n\n        const allReady = params.some(checkReadyState);\n\n        if (allReady && !this.syncSubscription) {\n          this.startSync();\n          this.syncSubscription.unsubscribe();\n        }\n      })).subscribe();\n    }\n\n    startSync() {\n      this.syncSubscription = timer(0, 1000).subscribe(() => {\n        for (const media in this.api.medias) {\n          if (this.api.medias[media] !== this) {\n            const diff = this.api.medias[media].currentTime - this.currentTime;\n\n            if (diff < -0.3 || diff > 0.3) {\n              this.playAtferSync = this.state === VgStates.VG_PLAYING;\n              this.pause();\n              this.api.medias[media].pause();\n              this.api.medias[media].currentTime = this.currentTime;\n            } else {\n              if (this.playAtferSync) {\n                this.play();\n                this.api.medias[media].play();\n                this.playAtferSync = false;\n              }\n            }\n          }\n        }\n      });\n    }\n\n    onMutation(mutations) {\n      // Detect changes only for source elements or src attribute\n      for (let i = 0, l = mutations.length; i < l; i++) {\n        const mut = mutations[i];\n\n        if (mut.type === 'attributes' && mut.attributeName === 'src') {\n          // Only load src file if it's not a blob (for DASH / HLS sources)\n          if (mut.target.src && mut.target.src.length > 0 && mut.target.src.indexOf('blob:') < 0) {\n            this.loadMedia();\n            break;\n          }\n        } else if (mut.type === 'childList' && mut.removedNodes.length && mut.removedNodes[0].nodeName.toLowerCase() === 'source') {\n          this.loadMedia();\n          break;\n        }\n      }\n    }\n\n    loadMedia() {\n      this.vgMedia.pause();\n      this.vgMedia.currentTime = 0; // Start buffering until we can play the media file\n\n      this.stopBufferCheck();\n      this.isBufferDetected = true;\n      this.bufferDetected.next(this.isBufferDetected); // TODO: This is ugly, we should find something cleaner. For some reason a TimerObservable doesn't works.\n\n      setTimeout(() => this.vgMedia.load(), 10);\n    }\n\n    play() {\n      // short-circuit if already playing\n      if (this.playPromise || this.state !== VgStates.VG_PAUSED && this.state !== VgStates.VG_ENDED) {\n        return;\n      }\n\n      this.playPromise = this.vgMedia.play(); // browser has async play promise\n\n      if (this.playPromise && this.playPromise.then && this.playPromise.catch) {\n        this.playPromise.then(() => {\n          this.playPromise = null;\n        }).catch(() => {\n          this.playPromise = null; // deliberately empty for the sake of eating console noise\n        });\n      }\n\n      return this.playPromise;\n    }\n\n    pause() {\n      // browser has async play promise\n      if (this.playPromise) {\n        this.playPromise.then(() => {\n          this.vgMedia.pause();\n        });\n      } else {\n        this.vgMedia.pause();\n      }\n    }\n\n    get id() {\n      // We should return undefined if vgMedia still doesn't exist\n      let result;\n\n      if (this.vgMedia) {\n        result = this.vgMedia.id;\n      }\n\n      return result;\n    }\n\n    get duration() {\n      return this.vgMedia.duration === Infinity ? this.specifiedDuration : this.vgMedia.duration;\n    }\n\n    set currentTime(seconds) {\n      this.vgMedia.currentTime = seconds; // this.elem.dispatchEvent(new CustomEvent(VgEvents.VG_SEEK));\n    }\n\n    get currentTime() {\n      return this.vgMedia.currentTime;\n    }\n\n    set volume(volume) {\n      this.vgMedia.volume = volume;\n    }\n\n    get volume() {\n      return this.vgMedia.volume;\n    }\n\n    set playbackRate(rate) {\n      this.vgMedia.playbackRate = rate;\n    }\n\n    get playbackRate() {\n      return this.vgMedia.playbackRate;\n    }\n\n    get buffered() {\n      return this.vgMedia.buffered;\n    }\n\n    get textTracks() {\n      return this.vgMedia.textTracks;\n    } // @ts-ignore\n\n\n    onCanPlay(event) {\n      this.isBufferDetected = false;\n      this.bufferDetected.next(this.isBufferDetected);\n      this.canPlay = true;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onCanPlayThrough(event) {\n      this.isBufferDetected = false;\n      this.bufferDetected.next(this.isBufferDetected);\n      this.canPlayThrough = true;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onLoadMetadata(event) {\n      this.isMetadataLoaded = true;\n      this.time = {\n        current: 0,\n        left: 0,\n        total: this.duration * 1000\n      };\n      this.state = VgStates.VG_PAUSED; // Live streaming check\n\n      const t = Math.round(this.time.total);\n      this.isLive = t === Infinity;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onWait(event) {\n      this.isWaiting = true;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onComplete(event) {\n      this.isCompleted = true;\n      this.state = VgStates.VG_ENDED;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onStartPlaying(event) {\n      this.state = VgStates.VG_PLAYING;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onPlay(event) {\n      this.state = VgStates.VG_PLAYING;\n\n      if (this.vgMaster) {\n        if (!this.syncSubscription || this.syncSubscription.closed) {\n          this.startSync();\n        }\n      }\n\n      this.startBufferCheck();\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onPause(event) {\n      this.state = VgStates.VG_PAUSED;\n\n      if (this.vgMaster) {\n        if (!this.playAtferSync) {\n          this.syncSubscription.unsubscribe();\n        }\n      }\n\n      this.stopBufferCheck();\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onTimeUpdate(event) {\n      const end = this.buffered.length - 1;\n      this.time = {\n        current: this.currentTime * 1000,\n        total: this.time.total,\n        left: (this.duration - this.currentTime) * 1000\n      };\n\n      if (end >= 0) {\n        this.buffer = {\n          end: this.buffered.end(end) * 1000\n        };\n      }\n\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onProgress(event) {\n      const end = this.buffered.length - 1;\n\n      if (end >= 0) {\n        this.buffer = {\n          end: this.buffered.end(end) * 1000\n        };\n      }\n\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onVolumeChange(event) {\n      // TODO: Save to localstorage the current volume\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onError(event) {\n      // TODO: Handle error messages\n      this.ref.detectChanges();\n    } // http://stackoverflow.com/a/23828241/779529\n\n\n    bufferCheck() {\n      const offset = 1 / this.checkInterval;\n      this.currentPlayPos = this.currentTime;\n\n      if (!this.isBufferDetected && this.currentPlayPos < this.lastPlayPos + offset) {\n        this.isBufferDetected = true;\n      }\n\n      if (this.isBufferDetected && this.currentPlayPos > this.lastPlayPos + offset) {\n        this.isBufferDetected = false;\n      } // Prevent calls to bufferCheck after ngOnDestroy have been called\n\n\n      if (!this.bufferDetected.closed) {\n        this.bufferDetected.next(this.isBufferDetected);\n      }\n\n      this.lastPlayPos = this.currentPlayPos;\n    }\n\n    startBufferCheck() {\n      this.checkBufferSubscription = timer(0, this.checkInterval).subscribe(() => {\n        this.bufferCheck();\n      });\n    }\n\n    stopBufferCheck() {\n      if (this.checkBufferSubscription) {\n        this.checkBufferSubscription.unsubscribe();\n      }\n\n      this.isBufferDetected = false;\n      this.bufferDetected.next(this.isBufferDetected);\n    }\n\n    seekTime(value, byPercent = false) {\n      let second;\n      const duration = this.duration;\n\n      if (byPercent) {\n        second = value * duration / 100;\n      } else {\n        second = value;\n      }\n\n      this.currentTime = second;\n    }\n\n    addTextTrack(type, label, language, mode) {\n      const newTrack = this.vgMedia.addTextTrack(type, label, language);\n\n      if (mode) {\n        newTrack.mode = mode;\n      }\n\n      return newTrack;\n    }\n\n    ngOnDestroy() {\n      this.vgMedia.src = '';\n      this.mutationObs.unsubscribe();\n      this.canPlayObs.unsubscribe();\n      this.canPlayThroughObs.unsubscribe();\n      this.loadedMetadataObs.unsubscribe();\n      this.waitingObs.unsubscribe();\n      this.progressObs.unsubscribe();\n      this.endedObs.unsubscribe();\n      this.playingObs.unsubscribe();\n      this.playObs.unsubscribe();\n      this.pauseObs.unsubscribe();\n      this.timeUpdateObs.unsubscribe();\n      this.volumeChangeObs.unsubscribe();\n      this.errorObs.unsubscribe();\n\n      if (this.checkBufferSubscription) {\n        this.checkBufferSubscription.unsubscribe();\n      }\n\n      if (this.syncSubscription) {\n        this.syncSubscription.unsubscribe();\n      }\n\n      this.bufferDetected.complete();\n      this.bufferDetected.unsubscribe();\n      this.api.unregisterMedia(this);\n    }\n\n  }\n\n  VgMediaDirective.ɵfac = function VgMediaDirective_Factory(t) {\n    return new (t || VgMediaDirective)(ɵngcc0.ɵɵdirectiveInject(VgApiService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  VgMediaDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: VgMediaDirective,\n    selectors: [[\"\", \"vgMedia\", \"\"]],\n    inputs: {\n      vgMedia: \"vgMedia\",\n      vgMaster: \"vgMaster\"\n    }\n  });\n  /** @nocollapse */\n\n  return VgMediaDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgPlayerComponent = /*#__PURE__*/(() => {\n  class VgPlayerComponent {\n    constructor(ref, api, fsAPI, controlsHidden) {\n      this.api = api;\n      this.fsAPI = fsAPI;\n      this.controlsHidden = controlsHidden;\n      this.isFullscreen = false;\n      this.isNativeFullscreen = false;\n      this.areControlsHidden = false;\n      this.onPlayerReady = new EventEmitter();\n      this.onMediaReady = new EventEmitter();\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n      this.api.registerElement(this.elem);\n    }\n\n    ngAfterContentInit() {\n      this.medias.toArray().forEach(media => {\n        this.api.registerMedia(media);\n      });\n      this.fsAPI.init(this.elem, this.medias);\n      this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n      this.subscriptions.push(this.controlsHidden.isHidden.subscribe(this.onHideControls.bind(this)));\n      this.api.onPlayerReady(this.fsAPI);\n      this.onPlayerReady.emit(this.api);\n    }\n\n    onChangeFullscreen(fsState) {\n      if (!this.fsAPI.nativeFullscreen) {\n        this.isFullscreen = fsState;\n        this.zIndex = fsState ? VgUtilsService.getZIndex().toString() : 'auto';\n      } else {\n        this.isNativeFullscreen = fsState;\n      }\n    }\n\n    onHideControls(hidden) {\n      this.areControlsHidden = hidden;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgPlayerComponent.ɵfac = function VgPlayerComponent_Factory(t) {\n    return new (t || VgPlayerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(VgApiService), ɵngcc0.ɵɵdirectiveInject(VgFullscreenApiService), ɵngcc0.ɵɵdirectiveInject(VgControlsHiddenService));\n  };\n\n  VgPlayerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgPlayerComponent,\n    selectors: [[\"vg-player\"]],\n    contentQueries: function VgPlayerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, VgMediaDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.medias = _t);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function VgPlayerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"z-index\", ctx.zIndex);\n        ɵngcc0.ɵɵclassProp(\"fullscreen\", ctx.isFullscreen)(\"native-fullscreen\", ctx.isNativeFullscreen)(\"controls-hidden\", ctx.areControlsHidden);\n      }\n    },\n    outputs: {\n      onPlayerReady: \"onPlayerReady\",\n      onMediaReady: \"onMediaReady\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([VgApiService, VgFullscreenApiService, VgControlsHiddenService])],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function VgPlayerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"\\n      vg-player {\\n        font-family: 'videogular';\\n        position: relative;\\n        display: flex;\\n        width: 100%;\\n        height: 100%;\\n        overflow: hidden;\\n        background-color: black;\\n      }\\n      vg-player.fullscreen {\\n        position: fixed;\\n        left: 0;\\n        top: 0;\\n      }\\n      vg-player.native-fullscreen.controls-hidden {\\n        cursor: none;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgPlayerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst services = [VgApiService, VgControlsHiddenService, VgFullscreenApiService, VgUtilsService, VgEvents, VgStates];\nconst directives = [VgCuePointsDirective, VgMediaDirective];\nlet VgCoreModule = /*#__PURE__*/(() => {\n  class VgCoreModule {}\n\n  VgCoreModule.ɵfac = function VgCoreModule_Factory(t) {\n    return new (t || VgCoreModule)();\n  };\n\n  VgCoreModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: VgCoreModule\n  });\n  VgCoreModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [...services],\n    imports: [[CommonModule]]\n  });\n  return VgCoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(VgCoreModule, {\n    declarations: function () {\n      return [VgCuePointsDirective, VgMediaDirective, VgPlayerComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [VgCuePointsDirective, VgMediaDirective, VgPlayerComponent];\n    }\n  });\n})();\n\nclass VgMediaElement {\n  get audioTracks() {\n    return null;\n  } // @ts-ignore\n\n\n  addTextTrack(kind, label, language) {\n    return null;\n  } // @ts-ignore\n\n\n  canPlayType(type) {\n    return null;\n  }\n\n  load() {}\n\n  msClearEffects() {}\n\n  msGetAsCastingSource() {\n    return null;\n  } // @ts-ignore\n\n\n  msInsertAudioEffect(_activatableClassId, _effectRequired, _config) {} // @ts-ignore\n\n\n  msSetMediaKeys(mediaKeys) {} // @ts-ignore\n\n\n  msSetMediaProtectionManager(mediaProtectionManager) {}\n\n  pause() {}\n\n  play() {\n    return null;\n  } // @ts-ignore\n\n\n  setMediaKeys(mediaKeys) {\n    return null;\n  } // @ts-ignore\n\n\n  addEventListener(_type, _listener, _useCapture) {}\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { VgApiService, VgControlsHiddenService, VgCoreModule, VgCuePointsDirective, VgEvents, VgFullscreenApiService, VgMediaDirective, VgMediaElement, VgPlayerComponent, VgStates, VgUtilsService }; //# sourceMappingURL=videogular-ngx-videogular-core.js.map","map":null,"metadata":{},"sourceType":"module"}